---
layout: post
title: Using Xaml serialization to generate Design Time Data
date: '2011-10-28T02:48:00.002-07:00'
author: Jan Fajfr
tags:
- MVVM
- Silverlight
modified_time: '2014-06-26T14:45:36.626-07:00'
thumbnail: http://1.bp.blogspot.com/-nVz7T8rrt0M/Tqp6QfZDHnI/AAAAAAAAAMs/eQvVsQa1elU/s72-c/web.PNG
blogger_id: tag:blogger.com,1999:blog-1710034134179566048.post-1057502579404958654
blogger_orig_url: http://hoonzis.blogspot.com/2011/10/using-xaml-serialization-to-generate.html
---

Recently I have been working on a almost finished Silverlight project which was needed a big change in graphical interfaces, in other words I needed a designer to be able to change all the Pages and components in Blend.<br /><br />The issue - well not real issues is that all the data was bounded to properties behind, and without the data, the desiner was not able to work change the UI.<br /><br />Blend can help you in this case, thanks to it's ability to <b>generate XAML data from an existing class. </b>So you can just generate data from existing ViewModel. That is great, but the problem is that, the data generated by Blend is not always usable. When you have an account and Blend will generate the name of the account: "Rhoncus vulputate" and the string specifing currency "Ipsum hac phasellus", you are thinking, maybe I will have to do some manual changes. Well with one account it is ok, but if you have a list of accounts (like 10) and list of operations (another 10). Editing all the things manulally might not be the right approach.<br /><br />Well it happens so that in our project, we are using <a href="http://autopoco.codeplex.com">AutoPoco</a> for the data generation. If you do not know it, it is a great library for generating simple POCO's - it seems like the development has been stoped last year, but hopefully this project will live on.<br /><br />Well basically this means that I have already a lot of meaningful data generated in the form of POCO's, later stored in the DB. I have also working application which connects to Web Services and generates the ViewModels on the client side, so I asked myself:<br /><b>Why should'nt I just take these ViewModels, serialize them into XAML and givem them to Blend as Design Time Data Sources?</b><br /><br />So my goal was to have the same data which I was using in execution time during design time. And as you can see at the two following pictures I got it to work.<br /><b>Run-time</b><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-nVz7T8rrt0M/Tqp6QfZDHnI/AAAAAAAAAMs/eQvVsQa1elU/s1600/web.PNG" imageanchor="1" style="margin-left:1em; margin-right:1em"><img border="0" height="253" width="320" src="http://1.bp.blogspot.com/-nVz7T8rrt0M/Tqp6QfZDHnI/AAAAAAAAAMs/eQvVsQa1elU/s320/web.PNG" /></a></div><br /><b>Design-time</b><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-byMCzZWo-0I/Tqp7NFkeigI/AAAAAAAAANE/U57JMMgpMwk/s1600/blend.PNG" imageanchor="1" style="margin-left:1em; margin-right:1em"><img border="0" height="187" width="320" src="http://3.bp.blogspot.com/-byMCzZWo-0I/Tqp7NFkeigI/AAAAAAAAANE/U57JMMgpMwk/s320/blend.PNG" /></a></div><br />So I set myself to try to do so:<br /><br /><b>First idea - use the XamlSerializer. The problem - this class is only presented in WPF - not in Silverlight. OK - I thought I will just use my ViewModels in WPF application.<br /></b><br />First Problem: The ViewModels were not ready to be used in WPF. Concretely I had two issues:<br /><ul><li>The INotifyDataErrorInfo interface does not exists (http://connect.microsoft.com/VisualStudio/feedback/details/568212/inotifydataerrorinfo-for-wpf)</li><li>The Web Service proxies generated using Silverlight are not the sames as the proxies generated using WPF</li></ul>Possible solulution to these issues:<br /><ul><li>Try to make your ViewModel completely platform independent. Reuse a DTO's (Data Transfer Objects) on the server and client side (do not let VS to generate proxies for your DTO projects).</li><li>Use #if SILVERLIGHT directive to specify which parts should be build for WPF and which for Silverlight.</li></ul>Well this turned out to be too complicated. Maybe it is possible on a project which you start from the very beginning. But I already had several ViewModels and changing all of these would take too much time.<br /><br /><b>Second idea - I will stay  in Silverlight and see if I can get the XamlSerializer working in Silverlight</b><br /><br />The build-int XamlSerializer is available only for WPF but there is an open-source implementation done by <a href="http://www.davidpoll.com/tag/silverlight-and-beyond-slab/">David Poll, which is part of his Silverlight and Beyond Library.</a><br />The use of the serializer is described in the <a href="http://www.davidpoll.com/2010/07/25/to-xaml-with-love-an-experiment-with-xaml-serialization-in-silverlight/">following blog post</a>.<br /><br />This saved my life, thought I had to do some changes.<br /><ul><li>To determine which properties to serialize, the Serializer uses the description provided <a href="http://blogs.msdn.com/b/mikehillberg/archive/2006/09/16/xamlwriter.aspx">on this blog</a>. So it will leave out all generic properties which are not read-only. In my case I had a lot of ObservableCollection<t> properties which I wanted to serialize. Actually this was the reason to try this approach, because I did not want to edit these collections for Blend by hand. To solve this issue I had to modify the <b>VisitProperty</b> method of the Serializer in order to force him to serialize even the writable generic properties.</li><li>Disable serialization of certain properties. Blend designer has problems with some special cases of XAML. Concretely I had problem with the serialized WCF proxies. When you generate a proxy, there are at least two classes generated. Service interface (ends with "Service") and Service implementation (ends with "Client"). Blend was unable to process the xaml when he was expecting property of type "Service" and I have given him "Client" it seems that it has problems regarding services and implementations. To overcome this issue I have introduced <b>XamlSerializationVisibility</b> attribute which can have two values (Visible and Hidden). This parameter allows me to specify to the XamlSerializer whether to seralize or not the property. Again a slight edit of the VisitProperty method was neede to check this attribute before serialization.</li><li>And at last, the original WPF XamlSerializer does not serialize all basic types. In my case I had several <b>Decimal</b> values which I wanted to serialize and they were skipped out. This was solved quite easy. XamlSerializer contains a class <b>BuiltInTypeConverter</b>. This class contains a list of types which can be serialized by simple conversion to String (<b>SupportedTypes</b>. I have added to this collection the <b>Decimal</b> and <b>DateTime</b> and it just worked.</li></ul>So thats it, grab the source code, try to serialize your ViewModels or whatever you need. Really a great thanks to David for the implementation of this class.<br /><br />