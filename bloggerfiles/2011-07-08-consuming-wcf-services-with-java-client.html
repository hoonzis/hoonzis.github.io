---
layout: post
title: Consuming WCF Services with Java Client
date: '2011-07-08T03:07:00.000-07:00'
author: Jan Fajfr
tags:
- Java
- WCF
modified_time: '2014-06-27T03:16:50.639-07:00'
thumbnail: http://4.bp.blogspot.com/-Yli21ev2fgI/TgdPxAh6YFI/AAAAAAAAAMI/4Na-cg7zLIU/s72-c/fidler_cookie.PNG
blogger_id: tag:blogger.com,1999:blog-1710034134179566048.post-291252293214641586
blogger_orig_url: http://hoonzis.blogspot.com/2011/07/consuming-wcf-services-with-java-client.html
---

Here is the state of my latest project: I have a Silverlight application which talks to traditional WCF services in backend. The services have so far been configured automatically - so let's say Visual Studio took care of the web.config. Newest requirement to my application was to allow Java clients consume these services.<br /><br />The prerequisites for this post are some basic knowledge of WCF (bindings, services, endpoints) and some knowledge of Java (I am using Axis to generate the clients...for the first time).<br /><br />To make it a bit more complicated: I was using FormsAuthentication on the backend side, since these services are hosted by IIS 7.<br /><br />Here I want to describe how to configure WCF services to be consumed by JAVA clients.<br />The second part which describes how to keep using Forms Authentication is described in <a href="{{ site.baseurl }}{% post_url 2011-07-08-aspnet-forms-authentication-and-java %}">my other post</a><br /><br />To expose the services for JAVA client, we have two options:<br /><ul><li>Expose the services using SOAP protocol</li><li>Expose the services using REST approach</li></ul>Both of these are possible with WCF. This ability to take existing services and expose them using different protocols and transfer formats is what makes WCF so powerful and useful.<br /><br />Here I will describe in details how to expose the services using SOAP protocol and in the end I will give a brief description of what to do to expose these services using REST approach.<br /><br /><h3>Changing WCF configuration</h3>The first step is to start changing WCF configuration which is presented in "web.config" file (at least in the case of service hosted in IIS).<br /><br />If you let Visual Studio configure your service, you will see that it creates for each services it's own binding - event though the services can share binding configuration.<br /><br />Also - if you consume service by Silverlight client, than VS chooses to define <b>binnaryMessageEncoding</b> as a transport format. Because both - the backend and the client are .NET applications, WCF can be configured to transfer the objects over the wires in binary format (because both the client and the server know how to serialize/deserialize) the data in this format. To consume the service by a Java application you will need to use a traditional <b>basicHttpBinding</b> - that is simple binding which uses standard WSDL specification in hand with XML serialization.<br /><br />So first step is to locate your binding and service definition and change the binding to <b>basicHttpBinding</b>.<br /><br /><pre class="prettyprint"><br />&ltbinding name="BinaryOverHTTPBinding"&gt<br />    &ltbinaryMessageEncoding /&gt<br />    &lthttpTransport /&gt<br />&lt/binding&gt<br />    <br />&ltservice name="Octo.Bank.Web.WCFServices.WCFUserService" behaviorConfiguration="NeutralBehavior"&gt<br />    &ltendpoint address="" binding="BinaryOverHTTPBinding" contract="MyProject.WCFUserService"/&gt<br />    &ltendpoint address="mex" binding="mexHttpBinding" contract="IMetadataExchange"/&gt<br />&lt/service&gt<br /></pre>Replace the binding configuration in the <b>endpoint</b> definition.<br /><pre class="prettyprint"><br />&ltendpoint address="" binding="basicHttpBinding" contract="MyProject.WCFUserService"/&gt<br /></pre><p>Just to completed the image here, the <b>service</b> is configured to user "NeutralBehavior".</p><pre class="prettyprint"><br />&ltbehavior name="NeutralBehavior"&gt<br />  &ltserviceMetadata httpGetEnabled="true"/&gt<br />  &ltserviceDebug includeExceptionDetailInFaults="false"/&gt<br />&lt/behavior&gt<br /></pre><p>What is important is, that the <b>httpGetEnabled</b> set to true in the combination with the <b>mex</b> endpoint will ensure that the WSDL definition of this service will be exposed (the url of the WSDL definition will be simply http://server/myService?wsdl).</p><p>Now that is the bare minimum to be able to connect to this WCFUserService with Java client.</p><h3>Defining the namespaces and ports</h3><p>While WCF Client, or Silverlight Client do not have a problem to generate a stub client for the defined service, when you will try to generate the client in java, you will obtain an exception saying that one of the port bindings was not properly defined. The cause is that you need to define different namespace and name in your <b>ServiceContract</b> and <b>ServiceBehavior</b>. These are two attributes which can be placed on top of your service class.</p><pre class="prettyprint"><br />[ServiceContract(Namespace = "octo.users.service",Name="UserService")]<br />[ServiceBehavior(Namespace = "octo.users.port", Name = "UserPort")]<br />[AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)]<br />public class WCFUserService { }<br /></pre>This completely changes the resulting <b>WSDL</b> file, which is describing the service. This is really important because if you do not make these changes, you will not be able to generate the client with Axis framework.<br /><br /><h3>Creating the Java client</h3><p>I am using Eclipse in combination with Axis framework to talk to my services. But first let's put out the 2 options that we have to access Web Services.</p><ul><li><b>Creating dynamically the client</b></li>- This option is more complicated because we have to now a bit how the service is defined in the WSDL file but allows us to perform some more changes on the SOAP messages that we want to send (for example changing the SOAP headers). <li><b>Using Axis to generate the client for us</b></li>- This is much easier, however it gives us only a limited ability to process the received SOAP messages. </ul><h3>Accessing Web Service using Axis created client</h3><p>Before we start, we need to generated the client, either you can use the build in tool in Eclipse ("New -> Other -> Web Service Client") or you can use the commander line "WSDLtoJava" utility. In both cases you have to enter just the URL of the WSDL.</p>When the client is ready, you can see that there is quite a lot of code(10kLines) generated for you.<br /><pre class="prettyprint"><br />MyServiceLocator locator = new MyServiceLocator();<br />AuthService client = locator.getBasicHttpBinding_AuthService();<br />String cookie = client.LoginCookie("login","password");<br /></pre><p>I am calling the method defined before which gives me the authentication cookie. Remember that this "Authentication Service" stays open, so anybody can call the methods. Now when we have the cookie, we can use it to make calls to other already protected services.</p><pre class="prettyprint"><br />MyServiceLocator locator = new MyServiceLocator();<br />WCFUserService client = locator.getBasicHttpBinding_WCFUserService();<br />((Stub)client)._setProperty(Call.SESSION_MAINTAIN_PROPERTY,new Boolean(true));<br />((Stub)client)._setProperty(HTTPConstants.HEADER_COOKIE, ".ASPXAUTH=" + <br />cookie);<br />Object data = client.GetSecuredData(myParam);<br /></pre><p>The generated client does not allow you to add cookies, but you can convert the client to <b>org.appache.axis.client.Stub</b> which allows you to call <b>_setProperty</b> method a static HttpConstatns class provides the names of the headers which you can set.</p><b>Now notice the "ASPXAUTH=" that is the prefix(or in other words the name) of the cookie and it has to be there</b>. It took me a while to find out in what exact form should I send the cookie, finally <a href="http://www.fiddler2.com/fiddler2/">Fiddler</a> came as help -  I used the Silverlight client to see what exactly he is sending and I just did the same.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-Yli21ev2fgI/TgdPxAh6YFI/AAAAAAAAAMI/4Na-cg7zLIU/s1600/fidler_cookie.PNG" imageanchor="1" style="margin-left:1em; margin-right:1em"><img border="0" height="114" width="320" src="http://4.bp.blogspot.com/-Yli21ev2fgI/TgdPxAh6YFI/AAAAAAAAAMI/4Na-cg7zLIU/s320/fidler_cookie.PNG" /></a></div><h3>Creating the client dynamically</h3><p>The <b>java.rmi</b> namespace provides classes allowing the creation of web service client on the fly (without code generation). This has some advantages, specially that you can create a <b>javax.rmi.xml.Service</b> class permitting you to assign special handlers, which are executed during the "reception" and "sending" of SOAP messages. These handlers can allow you to alter the content of the message and thus provide possibility to do some additional tuning, or security checks.</p><p>When working with WCF or CXF framework, you have probably heard of Interceptors, which are equivalent to "Handlers".</p>Personally I thought, that I will be able to create my own handler <b>to recuperate the authentication cookie</b> send the standard way. But I did not manage to get the cookie from the SOAP message. I will provide here a conception of my solution - maybe someone will be able to finalize and obtain the cookie from the response of the authentication service.<br /><pre class="prettyprint"><br />try {<br />  QName serviceName = new QName("http://mynamespace","AuthService");<br />  URL wsdlLocation = new URL("http://localhost:49830/WCFServices/WCFUserService.svc?wsdl");<br />  // Service<br />  ServiceFactory factory = ServiceFactory.newInstance();<br />  Service service =  factory.createService(wsdlLocation,serviceName);<br />  <br />  //Add the handler to the handler chain<br />  HandlerRegistry hr = service.getHandlerRegistry();<br />  HandlerInfo hi = new HandlerInfo();<br />  hi.setHandlerClass(SimpleHandler.class);<br />  handlerChain.add(hi);<br />  <br />  QName  portName = new QName("http://localhost:49830/WCFServices/WCFUserService.svc?wsdl", "BasicHttpBinding_AuthService");<br />  List handlerChain = hr.getHandlerChain(portName);<br />  <br />  QName operationName = new QName("http://localhost:49830/WCFServices/WCFUserService.svc?wsdl", "Login");<br />  Call call = service.createCall(portName,operationName);<br />  <br />  //call the operation<br />  Object resp = call.invoke(new java.lang.Object[] {"login","pass"});<br />}<br /></pre>To be able to call the web service dynamically, you will need to specify the name of the service, the port and the operations. You can find these easily in the WSDL definition file.<br />Here follows the definition of the <b>SimpleHandler</b> class which is added to the HTTP handler chain<br /><pre class="prettyprint"><br />public class SimpleHandler extends GenericHandler {<br /> <br />  HandlerInfo hi;<br /> <br />  public void init(HandlerInfo info) {<br />    hi = info;<br />  }<br /><br />  public QName[] getHeaders() {<br />    return hi.getHeaders();<br />  }<br /><br />  public boolean handleResponse(MessageContext context) {<br />    try {<br />     <br />     //Iterate over all properties - did not find the cookie there :(<br />     Iterator properties = context.getPropertyNames();<br />        while(properties.hasNext()){<br />         Object property = properties.next();<br />         System.out.println(property.toString());<br />        }<br />        <br />      //examine the response header - did not find the cookie there either :( <br />      if(context.containsProperty("response")){<br />       Object response = context.getProperty("response");<br />       HttpResponse httpResponse = (HttpResponse)response;<br />       <br />       Header[] headers = httpResponse.getAllHeaders();<br />       for(Header header:headers){<br />        System.out.println(header.toString());<br />       }<br />      }<br />     <br />     //here is how to get the SOAP headers - they do not serve - we need pure HTTP response<br />      // get the soap header<br />      SOAPMessageContext smc = (SOAPMessageContext) context;<br />      SOAPMessage message = smc.getMessage();<br />      <br />    } catch (Exception e) {<br />      throw new JAXRPCException(e);<br />    }<br />    return true;<br />  }<br />  public boolean handleRequest(MessageContext context) { <br />    return true;<br />  }<br />}<br /></pre><h3>Securing services by SSL</h3><p>In my other post I have described how to secure the web services by SSL, you can find the information which describes how to configure the JAVA client to connect to these secured services.</p><h3>REST approach</h3><p>To expose the service as RESTfull we will have to define another endpoint for the service.</p><pre class="prettyprint"><br />&ltservice behaviorConfiguration="NeutralBehavior" name="MyServic"&gt<br />  &ltendpoint address="json" binding="webHttpBinding"  behaviorConfiguration="jsonBehavior" contract="Octo.Bank.Web.WCFServices.WCFAccountService" name="JsonEndpoint"/&gt<br />  &ltendpoint address="soap" binding="basicHttpBinding" .../&gt<br />  &ltendpoint address="mex" .../&gt<br />&lt/service&gt<br /></pre>Notice that this endpoint uses <b>webHttpBinding</b> and a special behavior called <b>jsonBehavior</b>. This behavior as it's name says just defines JSON as the transport format.<br /><pre class="prettyprint"><br />&ltendpointBehaviors&gt<br />  &ltbehavior name="jsonBehavior"&gt<br />    &ltwebHttp defaultOutgoingResponseFormat="Json"/&gt<br />  &lt/behavior&gt<br />&lt/endpointBehaviors&gt<br /></pre>This is enough for the configuraiton. Now just some minor changes to the Service itself.<br />At the end I showed guidlines for exposing WCF services using the REST approach.<br /><pre class="prettyprint"><br />public class MyService {  <br />  [OperationContract]<br />  [WebGet(UriTemplate="/accounts?id={id}", BodyStyle=WebMessageBodyStyle.Wrapped)]<br />  public IList&ltAccountDto&gt GetAccountsByCustomer(int id)<br />  {<br />    return AccountService.GetCustomerAccounts(id);<br />  }<br />}<br /></pre>It is the <b>WebGet</b> attribute which exposes the service for HTTP GET request. The UriTemplate defines which URL will invoke the service. Notice that the parameter of the service is extracted from the URL itself.<br />If we would have a method which posts data, it would be decorated with [WebInvoke] attribute.<br />This is just a slight intro, you can find more information on internet, here I wanted just to provide some basic information to make this post complete enough.<br /><br /><h3>Summary</h3>I have shown how to change the configuration to publish WCF Service using SOAP protocol and consume this services with JAVA client. At the end I just showed how to expose the service using REST approach.