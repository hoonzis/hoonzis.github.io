---
layout: post
title: J2EE - NetBeans, JSF, Persistence API - Part 3
date: '2010-07-29T01:26:00.001-07:00'
author: Jan Fajfr
tags:
- Java
- JSF
- J2EE
modified_time: '2014-06-27T05:26:32.970-07:00'
thumbnail: http://4.bp.blogspot.com/_fmvjrARTMYo/TFcPE-ZjuZI/AAAAAAAAAHY/13-nbFLL-B4/s72-c/result.PNG
blogger_id: tag:blogger.com,1999:blog-1710034134179566048.post-5298151891570281471
blogger_orig_url: http://hoonzis.blogspot.com/2010/07/j2ee-netbeans-jsf-persistence-api-part.html
---

This blog entry is a continuation of a series in which I try to show how I taught myself the basics of J2EE. You can see the <a href="{{ site.baseurl }}{% post_url 2010-07-14-enterprise-java-netbeans %}"><b>first part</b></a> and following <a href="{{ site.baseurl }}{% post_url 2010-07-16-netbeans-enterprise-java-2-some-more-of %}"><b>second part</b></a>.<br />The aim of this part is to extend the detail page of a company by adding a list of products of the company and a drop down list box, which will allow a user to add a new product to the list of the products of the company. Here is who it should look like in the end.<br /><a href="http://4.bp.blogspot.com/_fmvjrARTMYo/TFcPE-ZjuZI/AAAAAAAAAHY/13-nbFLL-B4/s1600/result.PNG" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5500882048000440722" src="http://4.bp.blogspot.com/_fmvjrARTMYo/TFcPE-ZjuZI/AAAAAAAAAHY/13-nbFLL-B4/s320/result.PNG" style="cursor: pointer; display: block; height: 320px; margin: 0px auto 10px; text-align: center; width: 288px;" /></a><br />Generally adding the list of the products of the company to the page will be a piece of cake. You can again use the <b>dataTable</b> component provided by JSF. What will be a bit tricky is adding a drop down list. We will use the <b>selectOnListBox</b> component populated by <b>List<product></product></b>. Because this component allows to show <b>String</b> value and as I seed we will put in <b>Product</b> class. We will have to use a <b>Converter</b> component which will translate the <b>Product</b> to a single <b>String</b> and vice versa.<br /><h3>Changes to the Session Bean</h3><br />Again here I will start with the changes in the lower level. We will need to add a method which will provide all the products in the database as a List object. Later we will populate a drop down list with these products.<br /><pre class="prettyprint"><br />public List&lt;product&gt; getAllProducts() {<br /> List&lt;product&gt; products = em.createNamedQuery("Product.getAllProducts").getResultList();<br />return products;<br />}<br /></pre><br />This method is calling a named query which you need to place above the "Product" class declaration.<br /><pre class="prettyprint">@Entity<br />@NamedQuery(name="Product.getAllProducts",query="SELECT p FROM Product p")<br />public class Product implements Serializable {<br /><br />}<br /></pre><br />Then we will need a method which will find a product for a given ID. We can easily use u method of the Entity Manager which allows to find o object by a given ID (the ID field is decorated as a identity in the Entity Beans declaration. This method will be used by the <b>Converter</b> class.<br /><pre class="prettyprint"><br />public Product getProductWithId(String id) {<br />try {<br />  return em.find(Product.class, Integer.parseInt(id));<br />} catch (java.lang.NumberFormatException e) {<br />  e.printStackTrace();<br />}<br />return null;<br />}<br /></pre><br /><h3>The converter class</h3><br />As it had been said already, we will implement class which allows us convert  object of type <b>Product</b> to a <b>String</b>. This class has to implement <b>Converter</b> interface, provided by the JSF framework. This interface has two methods which have to be overriden <b>getAsObject</b> and <b>getAsString</b>. Both of these methods do have 3 arguments.<br /><br />The <b>FacesContext</b> specifies the context of the current request. FacesContext is an object which takes care of all the phases needed to render a response to the request. When an user demands an page, the users request is first processed by the <b>Faces Servlet</b>. If the call is a postback of previously viewed page, Faces Servlet will use the ID of the view and will look up the FacesContext of the page. If it is a initial view of the page, new FacesContext will be created. FacesContext connects the Component Tree of your page with the Backing Bean containing the logic. To get more information about the JSF life cycle and the FacesContext <a href="http://www.ibm.com/developerworks/library/j-jsf2/"><b>visit this series.</b></a>. Now the second argument is the UI Component to which the Converter is connected and the 3rd argument is either String value or Object - depends which way are you currently converting. Now - you just have to implement these method, you will probably never call them in your code. Here is my <b>ProductConverter</b> class which I decided to put into package <b>sales.util</b>.<br /><pre class="prettyprint"><br />public class ProductConverter implements Converter{<br />public Object getAsObject(FacesContext context, UIComponent component, String value) {<br />SalesSessionLocal ssb = lookupSessionBean();<br />Product p = ssb.getProductWithId(value);<br />return p;<br />}<br /><br />public String getAsString(FacesContext context, UIComponent component, Object value) {<br />String id = String.valueOf(((Product)value).getId());<br />return id;<br />}<br /><br />private SalesSessionLocal lookupSessionBean(){<br />try{<br />Context c = new InitialContext();<br />SalesSessionLocal ssb = (SalesSessionLocal) c.lookup("java:comp/env/SalesSessionBean");<br />return ssb;<br />}catch(NamingException ex){<br />return null;<br />}<br />}<br />}<br /></pre><br />The conversion of the object to the String is quite easy - you just need to decide what describes the object. Here you can see that I just return the products ID.<br />The conversion of an String to object is the processing of looking up the product of given ID in our Entity Manager. We had prepared a method for this lookup in the Sesion Bean, which we are basically calling by the following line.<br /><pre class="prettyprint"><br />Product p = ssb.getProductWithId(value);<br /></pre><br />Now the question is how to obtain the Session Bean. Normally in the Backing Bean we are using the EJB injection by the "@EJB" decoration. This means that we just write one single line and we obtain the Session Bean (no initialization, the framework takes care of this).<br /><pre class="prettyprint"><br />@EJB<br />SalesSessionLocal ssl;<br /></pre><br />However in the Converter you are not able to use this approach. The injection is allowed just in Managed Beans (another name for Backing Beans). The solution here is the usage of JNDI Lookup. JNDI - in general is a standard JAVA interface of locating users, computers but also objects and services. We need to lookup an object, concretely Session Bean, which is a part of the same J2EE application. The details of this lookup can be <a href="http://www.oracle.com/technology/sample_code/tech/java/oc4j/htdocs/Jndi/JNDIlookup.html"><b>found here</b></a>. Generally when the application server is started it creates for each application and <b>InitialContext</b>, which is an object that contains the Name - Object bindings. Using this InitialContext we can obtain the desired object if we know the name the object. We give the name to the object (Sesstion Bean) when we register it in the <b>web.xml</b> configuration file. Here is the registration of EJB in web.xml.<br /><pre class="prettyprint"><br />&lt;ejb-local-ref&gt;<br />&lt;ejb-ref-name&gt;SalesSessionBean&lt;/ejb-ref-name&gt;<br />&lt;ejb-ref-type&gt;Session&lt;/ejb-ref-type&gt;<br />&lt;local&gt;sales.SalesSessionLocal&lt;/local&gt;<br />&lt;ejb-link&gt;SalesManagement-ejb.jar#SalesSessionBean&lt;/ejb-link&gt;<br />&lt;/ejb-local-ref&gt;<br /></pre><br />And Here is how we can use the JNDI Lookup to get the Sesstion Bean in our GlassFish InitialContext.<br /><pre class="prettyprint"><br />Context c = new InitialContext();<br />SalesSessionLocal ssb = (SalesSessionLocal) c.lookup("java:comp/env/SalesSessionBean");<br /></pre><br /><h3>Changing Faces Configuration</h3><br />So that's it, the Convertor class is ready to be used. Now we have to register it in the Faces Configuration; in the <b>faces-config.xml</b> file add the following:<br /><pre class="prettyprint"><br />&lt;converter&gt;<br />&lt;description&gt;Converts Product Entity to String&lt;/description&gt;<br />&lt;converter-id&gt;ProductConverter&lt;/converter-id&gt;<br />&lt;converter-class&gt;sales.util.ProductConverter&lt;/converter-class&gt;<br />&lt;/converter&gt;<br /></pre><br /><h3>Changes to the Managed Bean (another name for Backing Bean)</h3><br />Now we will have to add some methods and fields to the Backing Bean to assure the functionality. First we will need to provide a field (and off course setters and getters) which will store the actual selected "Product" in the drop down list.<br /><pre class="prettyprint"><br />private Product selectedProduct;<br />public Product getSelectedProduct() {<br />return selectedProduct;<br />}<br /><br />public void setSelectedProduct(Product selectedProduct) {<br />this.selectedProduct = selectedProduct;<br />}<br /></pre><br />Now the next method called "addProduct" will just add the "selectedProduct" to the list of products of the current company.<br /><pre class="prettyprint"><br />public void addProduct(){<br />if(this.company.getProducts() == null){<br />this.company.setProducts(new ArrayList<product>());<br />}<br />this.company.getProducts().add(selectedProduct);<br />ssl.saveCompany(company);<br />}<br /></product></pre><br />The latest method will return a collection of products in as a list of <b>SelectItem</b>, which will represent the collection of products in the drop down list. This method benefits from the previously created method for getting all products in the Session Bean.<br /><pre class="prettyprint"><br />public List<selectitem> getAllProductsSelectList() {<br />List<selectitem> items = new ArrayList<selectitem>();<br />for (Product p : ssl.getAllProducts()) {<br />items.add(new SelectItem(p, p.getId() + " " + p.getName()));<br />}<br />return items;<br />}<br /></pre><br /><h3>Using the converter in the web page</h3><br />Now you should be ready to use to converter in your web page. Open the page with the details of the company ("company.jsp" in my case), and add the following table of products of one company.<br /><pre class="prettyprint"><br />&lt;h:datatable value="#{sales.company.products}" var="item"&gt;<br />&lt;h:column&gt;<br />&lt;f:facet name="header"&gt;&lt;h:outputtext value="Name"&gt;&lt;/h:outputtext&gt;&lt;/f:facet&gt;<br />&lt;h:outputtext value="#{item.name}"&gt;<br />&lt;/h:outputtext&gt;&lt;/h:column&gt;<br />&lt;h:column&gt;<br />&lt;f:facet name="header"&gt;&lt;h:outputtext value="Description"&gt;&lt;/h:outputtext&gt;&lt;/f:facet&gt;<br />&lt;h:outputtext value="#{item.description}"&gt;<br />&lt;/h:outputtext&gt;&lt;/h:column&gt;<br />&lt;/h:datatable&gt;<br /></pre>That is basically the same as done before in part 1, just notices that the table is binded to the list of the products of the "Company" object in Backing Bean. Now the following peace of code actually adds the drop down list box, which allows user to select one product and add it to the company.<br /><pre class="prettyprint"><br />&lt;h:outputtext value="Add Product:"&gt;&lt;/h:outputtext&gt;&lt;/h3&gt;<br />&lt;h:selectonelistbox size="1" value="#{sales.selectedProduct}"&gt;<br />&lt;f:selectitems value="#{sales.allProductsSelectList}"&gt;<br />&lt;f:converter converterid="ProductConverter"&gt;<br />&lt;/f:converter&gt;&lt;/f:selectitems&gt;&lt;/h:selectonelistbox&gt;<br />&lt;h:commandbutton action="#{sales.addProduct}" id="btnAdd" value="Add"&gt;<br />&lt;/h:commandbutton&gt;<br /></pre><br />You can see that the <b>selectOneListbox</b> component is binded to the "selectedProduct" field defined in the Backing Bean as well as the items list is binded to the list of products in the Backing Bean. The component also contains reference to the converter which should be used, which we have before prepared in the faces-config.xml. If you try this example right now, it will not work, instead you will obtain a strange validation error in your GlassFish log.<br />To be used by custom JSF converter, the entity class needs to override the <b>Equals</b> method. This is because the selected item is binded to the Backing Bean and when the selected item changes, it is compared to the binded field in the Backing Bean. So now you have to override the equals method for your "Product" class. To distinguish two products you can simply compare their IDs.<br /><pre class="prettyprint"><br />@Override<br />public boolean equals(Object obj){<br />  if (obj == null) {<br />    return false;<br />  }<br />  if (getClass() != obj.getClass()) {<br />     return false;<br />}<br /><br />final Product other = (Product) obj;<br />if (this.getId() != other.getId()) {<br />return false;<br />}<br />return true;<br />}<br /></pre><br />To try out your example you need some simple testing data. You can run this script (just check the names of the fields in the database tables before).<br /><pre class="prettyprint"><br />INSERT INTO SALES.COMPANY (companyname, companydescription) values('First company', 'Sales bananas');<br />INSERT INTO SALES.COMPANY (companyname, companydescription) values('Second company', 'Sales oranges');<br /><br />INSERT INTO SALES.PRODUCT (productname,productdescription) values ('Product 1','Orange');<br />INSERT INTO SALES.PRODUCT (productname,productdescription) values ('Product 2','Banana');<br /></pre><a href="https://skydrive.live.com/redir?resid=F8AFB4F072D6DB62!4913"><b>DOWNLOAD THE SOURCE CODE</b></a><br /><a href="{{ site.baseurl }}{% post_url 2010-07-14-enterprise-java-netbeans %}"><b>PART 1</b></a><br /><a href="{{ site.baseurl }}{% post_url 2010-07-16-netbeans-enterprise-java-2-some-more-of %}"><b>PART 2</b></a><br /><a href="{{ site.baseurl }}{% post_url 2010-07-29-j2ee-netbeans-jsf-persistence-api-part %}"><b>PART 3</b></a><br />