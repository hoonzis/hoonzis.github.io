---
layout: post
title: Provide JSONP with your WCF services (using .NET 3.5)
date: '2011-07-19T07:45:00.001-07:00'
author: Jan Fajfr
tags:
- WCF
modified_time: '2014-06-26T14:52:34.291-07:00'
blogger_id: tag:blogger.com,1999:blog-1710034134179566048.post-2193220764597818623
blogger_orig_url: http://hoonzis.blogspot.com/2011/07/provide-jsonp-with-your-wcf-services.html
---

I wrote this post mainly to correct one "bug", or let's say complete the MS example which shows how to configure your WCF services to provide data in JSONP format. <br /><br />This example works except the case when you are returning a raw JSON, that is you are not returning object which is serialized in to JSON, but rather returning a Stream which represents this JSON.<br /><br />The exception which you might obtain will be:<br /><br />Encountered invalid root element name 'Binary'. 'root' is the only allowed root element name.<br /><br /><h3>About JSONP</h3><br />JSON with Padding is a transport format, which uses the ability of SCRIPT tag to execute scripts from different domains to overcome the cross-domain access issue. Generally the returned JSON is wrapped by JavaScript function which can be executed cross-domain.<br /><br />So before we start - JSONP support is already added to .NET 4 so the services can be configured to use JSONP only by adding the CrossDomainScriptAccessEnabled attribute.<br /><br /><h3>When the problem occurs</h3>However I am stuck with NET 3.5 - so I needed to provide JSONP manually. Actually that is not that hard because MS provides this functionality in the WCF-WF example package (<a href="http://msdn.microsoft.com/en-us/library/cc716898(v=vs.90).aspx">Downloadable here</a>). <br /><br /><strong>The problem is, that this example is not complete. To be more specific: It works only when the service returns .NET objects which are serialized to JSON by WCF. However in some cases you might be serving the JSON which is already prepared. In this case your service returns a <b>Stream</b>. And in this case the example provided by MS will not work. </strong><br /><br />To understand the problem, we have to take a look at what exactly does the example of MS code. Well to start you can simply look at <a href="http://jasonkelly.net/2009/05/using-jquery-jsonp-for-cross-domain-ajax-with-wcf-services/">this blog.</a><br /><br />So basically to enable JSONP you just need to add JSONPBehavior attribute to your service. In fact this behavior uses JSONPEncoderFactory class, which defines an encoder (JSONPEncoder) which converts the messages to JSONP. The encoding takes place in the override WriteMessage method. Let's take a look at the method provided in the MS example.<br /><pre class="brush:prettyprint"><br />public override ArraySegment&ltbyte&gt WriteMessage(Message message, int maxMessageSize, BufferManager bufferManager, int messageOffset)<br />{<br />    MemoryStream stream = new MemoryStream();<br />    StreamWriter sw = new StreamWriter(stream);<br /><br />    string methodName = null;<br />    if (message.Properties.ContainsKey(JSONPMessageProperty.Name))<br />        methodName = ((JSONPMessageProperty)(message.Properties[JSONPMessageProperty.Name])).MethodName;<br /><br />    if (methodName != null)<br />    {<br />        sw.Write(methodName + "( ");<br />        sw.Flush();<br />    }<br />    XmlWriter writer = JsonReaderWriterFactory.CreateJsonWriter(stream);<br />    message.WriteMessage(writer);<br />    writer.Flush();<br />    if (methodName != null)<br />    {<br />        sw.Write(" );");<br />        sw.Flush();<br />    }<br /><br />    byte[] messageBytes = stream.GetBuffer();<br />    int messageLength = (int)stream.Position;<br />    int totalLength = messageLength + messageOffset;<br />    byte[] totalBytes = bufferManager.TakeBuffer(totalLength);<br />    Array.Copy(messageBytes, 0, totalBytes, messageOffset, messageLength);<br /><br />    ArraySegment&ltbyte&gt byteArray = new ArraySegment&ltbyte&gt(totalBytes, messageOffset, messageLength);<br />    writer.Close();<br />    return byteArray;<br />}<br /></pre><br />So what is happening here: the <b>Message</b> object contains the object which returns your method. The WriteMessage method will take this object and write it to a Stream which is passed to it in argument. In the method the passed stream is a <b>JsonWriter</b>. The problem is that JsonWriter expects the structure of the message to be object represented by XML, which it will convert to JSON.<br /><br />Now you can see that before we are actually writing the content of the message, we write "methodName(" and after ");". Generally this is the wrapping by JavaScript function. The result will be something like "methodName({JSONOBject});".<br /><br />The resulted Stream is than just converted to byte array.<br /><br />This works, but the problem is that when you are returning raw JSON, in other words, that your method returns <b>Stream</b>, than you cannot use JsonWriter, because the Message.WriteMessage will push to the writer XML of different structure, than it expects.<br /><br />To be specific the XML will have a form of &lt;binary&gt;asdqwetasfd&lt;/Binary&gt; and JsonWriter will not be able to create reasonable Json object.<br /><br /><h3>Solution</h3>The solution to the problem is following:<br /><ul><li>Check the format of the message (if it Json or Raw Stream)</li><li>If it is a Raw Stream, than just convert the Stream to array of bytes</li><li>If it is Json, than use the same procedure as before</li></ul><pre class="prettyprint"><br />public override ArraySegment&ltbyte&gt WriteMessage(Message message, int maxMessageSize, BufferManager bufferManager, int messageOffset)<br />{<br />    WebContentFormat messageFormat = this.GetMessageContentFormat(message);<br /><br />    MemoryStream stream = new MemoryStream();<br />    StreamWriter sw = new StreamWriter(stream);<br /><br />    string methodName = null;<br />    if (message.Properties.ContainsKey(JSONPMessageProperty.Name))<br />        methodName = ((JSONPMessageProperty)(message.Properties[JSONPMessageProperty.Name])).MethodName;<br /><br />    if (methodName != null)<br />    {<br />        sw.Write(methodName + "( ");<br />        sw.Flush();<br />    }<br /><br />    XmlWriter writer = null;<br />    if (messageFormat == WebContentFormat.Json)<br />    {<br />        writer = JsonReaderWriterFactory.CreateJsonWriter(stream);<br />        message.WriteMessage(writer);<br />        writer.Flush();<br />        //writer.Close();<br />    }<br />    else if (messageFormat == WebContentFormat.Raw)<br />    {<br />        String messageBody = ReadRawBody(ref message);<br />        sw.Write(messageBody);<br />        sw.Flush();<br />    }<br /><br />    if (methodName != null)<br />    {<br />        sw.Write(" );");<br />        sw.Flush();<br />    }<br /><br />    byte[] messageBytes = stream.GetBuffer();<br />    int messageLength = (int)stream.Position;<br />    int totalLength = messageLength + messageOffset;<br />    byte[] totalBytes = bufferManager.TakeBuffer(totalLength);<br />    Array.Copy(messageBytes, 0, totalBytes, messageOffset, messageLength);<br /><br />    ArraySegment&ltbyte&gt byteArray = new ArraySegment&ltbyte&gt(totalBytes, messageOffset, messageLength);<br />    stream.Close();<br />    <br />    return byteArray;<br />} <br /></pre><br />You can see that I am using two additional methods: <b>GetMessageContentFormat</b> and <b>ReadRawBody</b>. I did not came up with these methods, instead I have borrowed them from the <a href="http://blogs.msdn.com/b/carlosfigueira/archive/2011/04/19/wcf-extensibility-message-inspectors.aspx">blog of Carlos Figueira</a><br />In his blog, he describes how to use these methods when Inspecting messages. That is not the same scenario, but actually Inspecting outgoing methods or creating own MessageEncoder are just two ways to achieve the same thing.<br />I will add the definitions of the methods here, but the above mentioned blog post is a great source of information regarding customization of WCF Service, definitely worth checking.<br /><br /><pre class="prettyprint"><br />private WebContentFormat GetMessageContentFormat(Message message)<br />            {<br />                WebContentFormat format = WebContentFormat.Default;<br />                if (message.Properties.ContainsKey(WebBodyFormatMessageProperty.Name))<br />                {<br />                    WebBodyFormatMessageProperty bodyFormat;<br />                    bodyFormat = (WebBodyFormatMessageProperty)message.Properties[WebBodyFormatMessageProperty.Name];<br />                    format = bodyFormat.Format;<br />                }<br /><br />                return format;<br />            }<br /><br />private String ReadRawBody(ref Message message)<br />            {<br />                <br />                XmlDictionaryReader bodyReader = message.GetReaderAtBodyContents();<br />                <br />                bodyReader.ReadStartElement("Binary");<br />                byte[] bodyBytes = bodyReader.ReadContentAsBase64();<br />                <br />                string messageBody = Encoding.UTF8.GetString(bodyBytes);<br /><br />                // Now to recreate the message<br />                MemoryStream ms = new MemoryStream();<br />                XmlDictionaryWriter writer = XmlDictionaryWriter.CreateBinaryWriter(ms);<br />                writer.WriteStartElement("Binary");<br />                writer.WriteBase64(bodyBytes, 0, bodyBytes.Length);<br />                writer.WriteEndElement();<br />                writer.Flush();<br />                ms.Position = 0;<br />                XmlDictionaryReader reader = XmlDictionaryReader.CreateBinaryReader(ms, XmlDictionaryReaderQuotas.Max);<br />                Message newMessage = Message.CreateMessage(reader, int.MaxValue, message.Version);<br />                newMessage.Properties.CopyProperties(message.Properties);<br />                message = newMessage;<br />                //return bodyBytes;<br />                return messageBody;<br />            }<br /></pre>