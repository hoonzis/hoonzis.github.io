---
layout: post
title: Spring MVC simple project (Spring by example)
date: '2011-02-23T15:50:00.002-08:00'
author: Jan Fajfr
tags:
- J2EE
- spring
modified_time: '2014-06-27T02:24:23.011-07:00'
thumbnail: http://1.bp.blogspot.com/-_dTtQK_AOfI/TWWcttkD9uI/AAAAAAAAAI8/bIA2WbWE2ts/s72-c/students.PNG
blogger_id: tag:blogger.com,1999:blog-1710034134179566048.post-5496261131107564255
blogger_orig_url: http://hoonzis.blogspot.com/2011/02/spring-mvc-simple-project-spring-by.html
---

<p>This semester I had to do a bigger project using Spring Framework &amp; Hibernate. On a side of this project I had a smaller one which I have created just to always try out certain parts which later I applied to the bigger one. Here I just present the simple project which should be easy to understand, but it contains all the important parts/frameworks/design patterns of enterprise applications: MVC, ORM, Validations, Security, Internalization, Views/ Tiles, Unit Tests.</p><p>I do not have much experience working with J2EE, or writing enterprise Java applications, so this will maybe help someone who is on the same Java level as I am.</p><p><a href="https://onedrive.live.com/redir.aspx?cid=f8afb4f072d6db62&resid=F8AFB4F072D6DB62!4915&parId=F8AFB4F072D6DB62!4912&authkey=!ALHYiWWtLLCdhKw">Download the project here</a></p><p>Now this is the resulting application:</p><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-_dTtQK_AOfI/TWWcttkD9uI/AAAAAAAAAI8/bIA2WbWE2ts/s1600/students.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="292" src="http://1.bp.blogspot.com/-_dTtQK_AOfI/TWWcttkD9uI/AAAAAAAAAI8/bIA2WbWE2ts/s320/students.PNG" width="320" /></a></div><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-oOhl2KRvNu0/TWWcz_jtCQI/AAAAAAAAAJE/dsyyVl5BbHQ/s1600/courses.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="284" src="http://4.bp.blogspot.com/-oOhl2KRvNu0/TWWcz_jtCQI/AAAAAAAAAJE/dsyyVl5BbHQ/s320/courses.PNG" width="320" /></a></div><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-QXf0RVF3iSU/TWWc4nHhLcI/AAAAAAAAAJM/fruZNxQct-0/s1600/studentcourses.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="275" src="http://3.bp.blogspot.com/-QXf0RVF3iSU/TWWc4nHhLcI/AAAAAAAAAJM/fruZNxQct-0/s320/studentcourses.PNG" width="320" /></a></div>You can see, that it is a basic application containing: Student and Courses. There is one Many To Many relationship, while each student can have many courses and each course can be followed by many students.<br /><br /><h3>Basic setup of the project</h3>This is Eclipse "Dynamic Web Application" Project. I have used the latest Eclipse 3.6, Java 1.6 and Tomcat 6. However this should not limit to run the project with different configurations, however changing to Java 1.5 would require some additional changes (@Override annotations).<br />In the following image you can see the two groups first the source files and second all the important configuration files. Here is brief overview:<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-I_ffD86c_ZE/TWGaCcuafFI/AAAAAAAAAIo/gloMHFTlC3E/s1600/project_structure.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="http://3.bp.blogspot.com/-I_ffD86c_ZE/TWGaCcuafFI/AAAAAAAAAIo/gloMHFTlC3E/s320/project_structure.PNG" width="185" /></a></div><br /><br /><ul><li><b>web.xml</b> - Web Deployment Descriptor, the base of the configuration for all the parts that compose the web application.</li><li><b>tiles.xml</b> - Configuration of Appache Tiles - templating framework, used to define reutilisable parts of web pages.</li><li><b>spring-servlet.xml</b> - Spring configuration part. Described lower.</li><li><b>jdbc.properties</b> - This file just holds the properties of the database connection.</li><li><b>applicationContext-security.xml</b> - Configuration of Spring Security Framework.</li></ul><br /><h3>Package and project structure</h3>The project has a common structure:<br /><b>View &lt;--&gt; Controller &lt;--&gt; Service &lt;--&gt; Repository &lt;--&gt; DB</b>.<br />The Repository pattern (implemented by the classes in the DAO package) allows the abstraction of the DB technology. The Service layer has implemented all the functions of the project. For example in the StudetsService class you can find all methods concerning the students (add a course to student, create new student..).<br />The Controller layer uses the Service layer to fill the model needed behind the view and to perform the tasks desired by the user.<br /><br /><h3>Model View Controller with Spring</h3>The MVC software architecture permits separate the domain model (M), the logic (C) and the user interface (V). Spring implementation of MVC is based on DispatcherServlet. DispatcherServlet is classical HttpServlet which decides to which Controller the current request should be sent and which View should be used to render the reponse.<br />Please refer to the <a href="http://static.springsource.org/spring/docs/3.0.x/reference/mvc.html">Oficial Documentation</a> which contains great explanation.<br />In the web.xml the DispatcherServlet is defined to handle all the requests coming to the web site (see url-pattern).<br /><pre class="prettyprint"><br />&lt;servlet&gt;<br />   &lt;servlet-name&gt;spring&lt;/servlet-name&gt;<br />   &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;<br />   &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;<br />  &lt;/servlet&gt;<br />  &lt;servlet-mapping&gt;<br />   &lt;servlet-name&gt;spring&lt;/servlet-name&gt;<br />   &lt;url-pattern&gt;/&lt;/url-pattern&gt;<br />  &lt;/servlet-mapping&gt;<br /><br />  &lt;context-param&gt;<br />  &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;&lt;param-value&gt;/WEB-INF/spring-servlet.xml<br />   /WEB-INF/applicationContext-security.xml<br />  &lt;/param-value&gt;&lt;/context-param&gt;<br />  <br />  &lt;listener&gt;<br />    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;<br />  &lt;/listener&gt;<br /></pre><p>In the servlet mapping part, the servlet-name is set to "spring". This servlet needs some special configuration and this will be provided by spring-servlet.xml file. But in order to tell Spring where to search te configuration we set the path of this file as the parametr to the Spring ContextLoader. There is also a link to the file which provides security configuration. Spring-servlet.xml contains a lot of configuration. Lets now take a look at the part concerning the view.</p><br /><h2>Apache Tiles</h2>With spring you can use several APIs or technologies to build you user interface: standard JSP, Java Server Faces, Apache Tiles (they do not compete, they serve for different purposes and sometimes overlap). In this project I am using Apacha Tiles. That is a framework which allowes you to define a fragments or parts which can be reused in several web pages (typically for example you have a menu bar, which is always present).<br />In the Spring-servlet.xml this is the part concerning Tiles:<br /><pre class="prettyprint"><br />&lt;bean class="org.springframework.web.servlet.view.UrlBasedViewResolver" id="viewResolver"&gt;<br />     &lt;property name="viewClass"&gt;<br />         &lt;value&gt;<br />             org.springframework.web.servlet.view.tiles2.TilesView<br />         &lt;/value&gt;<br />     &lt;/property&gt;<br /> &lt;/bean&gt;<br /> &lt;bean class="org.springframework.web.servlet.view.tiles2.TilesConfigurer" id="tilesConfigurer"&gt;<br />     &lt;property name="definitions"&gt;<br />         &lt;list&gt;<br />             &lt;value&gt;/WEB-INF/tiles.xml&lt;/value&gt;<br />         &lt;/list&gt;<br />     &lt;/property&gt;<br /> &lt;/bean&gt;<br /></pre><p>That tells Spring, that all the views should be resolved using TilesView class and the configuration can be found in the tiles.xml file.</p><h2>Tiles Configuration</h2>First declared in the Tiles configuration file is the layout. So a specific page(layout.jsp) which defines the layout of our pages and links to jsp pages which represent these parts. After this definition come the declarations of each view. Each view specifies which layout it uses and the parts which should be imported.<br /><pre class="prettyprint"><br />&lt;tiles-definitions&gt;<br />    &lt;definition name="base.definition" template="/WEB-INF/jsp/layout.jsp"&gt;<br />        &lt;put-attribute name="title" value=""&gt;<br />        &lt;put-attribute name="header" value="/WEB-INF/jsp/header.jsp"&gt;<br />        &lt;put-attribute name="menu" value="/WEB-INF/jsp/menu.jsp"&gt;<br />        &lt;put-attribute name="body" value=""&gt;<br />        &lt;put-attribute name="footer" value="/WEB-INF/jsp/footer.jsp"&gt;<br />    &lt;/put-attribute&gt;&lt;/put-attribute&gt;&lt;/put-attribute&gt;&lt;/put-attribute&gt;&lt;/put-attribute&gt;&lt;/definition&gt;<br /> <br />    &lt;definition extends="base.definition" name="students"&gt;<br />        &lt;put-attribute name="title" value="Users management"&gt;<br />        &lt;put-attribute name="body" value="/WEB-INF/jsp/students.jsp"&gt;<br />    &lt;/put-attribute&gt;&lt;/put-attribute&gt;&lt;/definition&gt;<br />&lt;/tiles-definitions&gt;<br /></pre><p>Take a look at the <b><i>layout.jsp</i></b> file and you will fast understand how it works.</p><h2>MVC implementation</h2>To understand how MVC works open one of the Controller classes, for example: <b>StudentsController</b><br /><pre class="prettyprint"><br />@Controller<br />public class StudentsController {<br /><br /> @Autowired<br /> private StudentsService studentsService;<br /><br /> @RequestMapping("/students")<br /> public String listUsers(ModelMap model){<br />  model.addAttribute("student",new Student());<br />  List&lt;student&gt; users = studentsService.listStudents();<br />  model.addAttribute("studentsList",users);<br />  return "students";<br /> }<br /> <br />  @RequestMapping(value = "/addstudent", method = RequestMethod.POST)<br />    public String addContact(@ModelAttribute("student")<br />    Student user, BindingResult result) {<br /> <br />   studentsService.addStudent(user);<br />        return "redirect:/students";<br />    }<br /> <br />    @RequestMapping("/delete/{studentID}")<br />    public String deleteContact(@PathVariable("studentID")<br />    Integer studentID) {<br />     studentsService.removeStudent(studentID);<br />        return "redirect:/students";<br />    }<br />}<br /></pre>There is a private field of type StudentsService. You can see that it is annotated with @Autowired. This service provides all the methods needed to manipulate students. The @Autowire annotation tells Spring, that it should automatically instantiate this field from it's Dependency Injection container (in other words you do not have to take care about the creation of object).<br />Next there are 3 methods with different signatures all of them annotated with @RequestMapping. The MVC framework binds the URL given in the decoration with the controller and with the execution of the decorated method. In other words when the user navigates to "..TestingProject/students.do" this method will be processed to construct the Model and to return the View to the user.<br />As said before the methods have different signatures depending on their neeeds but the are some rules which have to be kept. (<a href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/mvc.html#mvc-ann-requestmapping-uri-templates)">see the documentation</a>).<br />The most straightforward is the method <b>listStudents</b>. This method fills the given Model (which is passed to the method by MVC framework) and returns the name of the view which should be used to show this model. You can take a look at the Tiles configuration to see which JSP will be shown after returning "students" as the name of the view.<br /><br /><h3>Object Relational Mapping - the Domain</h3>In the Domain package you can find just two classes: Student and Course. This is the Student class:<br /><pre class="prettyprint"><br />@Entity<br />@Table(name="student")<br />public class Student {<br /><br /> @Id<br /> @GeneratedValue<br /> private Integer id;<br /> <br /> @ManyToMany<br /> @JoinTable(name="student_course"<br />  ,joinColumns=@JoinColumn(name="student_id")<br />  ,inverseJoinColumns=@JoinColumn(name="course_id"))<br /> private List<course> follows;<br /> <br /> @Column<br /> private String firstname;<br /> <br /> @Column<br /> private String lastname;<br /><br /> @Column<br /> private String email;<br /> <br /> @Column<br /> private Integer phone;<br /> public Integer getId() {<br />  return id;<br /> }<br />  ...getters and setters...<br />}<br /></pre>The @Entity annotation tells hibernate that this class represents and entity which should be stored in the database, the @Table annotation details the name of the table used to store these entities.<br />Each field of this class is annotated with @Column annotation - this tells Hibernate that each field should be persisted as separated column.<br />The @Id and @GeneratedValue annotations over the id field specify that this field represents the primary key and that the value of this key should be automatically generated whenever persisting a new entity in the table.<br />And last @ManyToMany and @JointTable annotations represent the N to N relationship between students and Courses. In common words Student can have several Courses and a Course can have several students.<br />The @JoinTable annotation specifies exactly which table should represents the N - N relation ship and declare the foreign keys in this table. Note that there are different ways to manage this using Hibernate (look for @ManyToMany and @MappedBy annotations).<br />The course class is quite similar and I will not describe it here.<br /><h3>Internalization / Localization</h3>It is quite common demand to make the application supporting multipel languages. Spring framework provides LocalChangeInterceptor, which based on parametr in the url of the page decides, which languages version of the page should be loaded. To configure this feature take a look at the <b>spring-servlet.xml</b> file which contains the 3 following beans:<br /><br /><pre class="prettyprint"><br />&lt;!-- Messages and Internalization --&gt;<br />    &lt;bean id="messageSource"<br />        class="org.springframework.context.support.ReloadableResourceBundleMessageSource"&gt;<br />        &lt;property name="basename" value="classpath:messages" /&gt;<br />        &lt;property name="defaultEncoding" value="UTF-8" /&gt;<br />    &lt;/bean&gt;<br />    <br />    &lt;bean id="localeChangeInterceptor"<br />     class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"&gt;<br />        &lt;property name="paramName" value="lang"/&gt;<br />    &lt;/bean&gt;<br /> <br />    &lt;bean id="localeResolver"<br />   class="org.springframework.web.servlet.i18n.CookieLocaleResolver"&gt;<br />   &lt;property name="defaultLocale" value="en"/&gt;<br />    &lt;/bean&gt;<br /></pre>The first bean defines the store for the strings in multiple languages. Here it aims at all files which look like "messages*" placed in the classpath, defining the UTF-8 as the default encoding to save the strings.<br />The second bean is the above mention language interceptor. The <b>paramName property</b> tells spring to look at the "lang" url parameter before composing the final web page.<br />The last bean defines which implementation of LocalResolver interface should be used to define the language. Here it is CookieLocalResolver. An implementation which uses a cookie sent to the user, which later can be retrieved to determine the language.<br />Now in the resources you can localize two files: <b>messages_en.properties</b> and <b>messages_fr.properties</b>. These two files contain a simple list of key-value pairs defining the strings used in the application and the translations.<br />Now the last step is to take a look in how these strings are references in the web pages. For that take a look for example at <b>menu.jsp</b> which defines the left side menu of the application.<br /><pre class="prettyprint"><br />&lt;%@taglib uri="http://www.springframework.org/tags" prefix="spring"%&gt;<br />&lt;p&gt;&lt;spring:message code="label.menu"/&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="/TestingProject/students"&gt;&lt;spring:message code="label.students"/&gt;&lt;/a&gt;&lt;/li&gt;<br />&lt;li&gt;&lt;a href="/TestingProject/courses"&gt;&lt;spring:message code="label.courses"/&gt;&lt;/a&gt;&lt;/li&gt;<br />&lt;/ul&gt;<br /></pre><p>Here you can see that instead of writing the string inside of the A tag, the <b>spring:message</b> tag is used which loads the correct string identified by the "label.students" key.</p><h3>Security</h3>Now the security is taken care of by Spring Security (former Acegi Security) framework and I use the very basic settings. Spring Security in its core uses basic Filter and FilterChain interfaces which are defined in the core of Java Servlet application and are generally code parts responsible for composing or caching the content to be send to the user.<br />In the <b>web.xml</b> file the following parts instruct the application to use the org.springframework.web.filter.DelegatingFilterProxy class for filtering all url (pattern set in the filter-mapping part). This filter is later responsible for allowing access to certain parts only to users with certain rights. To get more information refer to this official <a href="http://static.springsource.org/spring-security/site/docs/3.0.x/reference/security-filter-chain.html">"The Security Filter Chain" page.</a>. For more information about filters in general <a href="http://onjava.com/pub/a/onjava/2003/11/19/filters.html">visit this page.</a>.<br />The first part of the security settings is defined in separated <b>applicationContext-security.xml</b> file.<br />First the following <b>authentication-manager</b> tells spring that the user is authentified against the database. The same data source is already used for ORM mapping.<br /><pre class="prettyprint"><br />&lt;authentication-manager&gt;<br />  &lt;authentication-provider&gt;<br />    &lt;jdbc-user-service data-source-ref="dataSource"/&gt;<br />  &lt;/authentication-provider&gt;<br />&lt;/authentication-manager&gt;<br /></pre><br />However the precedent snippet does not define how the security data is stored in the database. That is because it uses the default implementation. In other words Spring expects you to provide the data source with default structure. This structure is composed of two tables: <b>users</b> and <b>authorities</b>. To see the details take a look at the <a href="http://static.springsource.org/spring-security/site/docs/3.0.x/reference/appendix-schema.html">Apendix A of Spring documentation.</a> And if you just want to have the DB structure you can create it with <b>security_db.sql</b> script which is part of the project:<br /><pre class="prettyprint"><br />create table users(<br />      username varchar(50) not null primary key,<br />      password varchar(50) not null,<br />      enabled boolean not null);<br /><br />  create table authorities (<br />      username varchar(50) not null,<br />      authority varchar(50) not null,<br />      constraint fk_authorities_users foreign key(username) references users(username));<br />      create unique index ix_auth_username on authorities (username,authority);<br /></pre><br />So we have the users which have roles and the data is stored in the database. Now the way it is used is specified in the second part of "applicationContext-security.xml".<br /><pre class="prettyprint"><br />&lt;http auto-config="true"&gt;<br />        &lt;intercept-url pattern="/admin/*.do" access="ROLE_ADMIN"/&gt;<br />        &lt;intercept-url pattern="/**" access="ROLE_USER,ROLE_ADMIN,ROLE_TEACHER"/&gt;<br />        &lt;intercept-url pattern="/login.jsp*" filters="none"/&gt;<br />        &lt;form-login login-page='/login.jsp'/&gt;<br />&lt;/http&gt;<br /></pre>Here we assign to url patterns the roles that users need to have in order to access these urls.<br />Well that's it. But this is just a very simple way of implementing security. There are more advanced manners of securing the method calls or visibility of html elements always based on user roles.<br /><h3>Hints for the other aspects enterprise application</h3>Unfortunately I did not have time to include in this simple project some other aspects of enterprise applications.<br /><h4>Validations</h4>To implement data validations spring contains org.springframework.validation space, which contains a Validator interface containing "validate" method. Here is a short example of how validator could be implemented for a "User" class:<br /><pre class="prettyprint"><br />public class UserValidator implements Validator {<br />  <br /> @Override<br /> public boolean supports(Class<?> arg0) {<br />  return User.class.isAssignableFrom(arg0);<br /> }<br /><br /> @Override<br /> public void validate(Object arg0, Errors arg1) {<br />  User user = (User) arg0;<br />  if(!isValidEmailAddress(user.getAdresse_mail())){<br />   arg1.rejectValue("adresse_mail","adresse_mail.notValid","Not a valid email");<br />  }<br />  <br /> }<br /> <br /> public boolean isValidEmailAddress(String emailAddress){  <br />     String  expression="^[\\w\\-]([\\.\\w])+[\\w]+@([\\w\\-]+\\.)+[A-Z]{2,4}$";  <br />     CharSequence inputStr = emailAddress;<br />     Pattern pattern = Pattern.compile(expression,Pattern.CASE_INSENSITIVE);  <br />     Matcher matcher = pattern.matcher(inputStr);  <br />     return matcher.matches();<br />   } <br />}<br /></pre>In this example I am using Regular Expressions to determine whether the specified email is in valid form.<br />Another way of validating would be to use the JSR 303 validation specification, which defines the validation model based on annotations. This allows you to annotate field of you domain class and thus specify the way this field should look like. In the following example the @Email annotation would take care of what the above implementation does.<br /><br /><pre class="prettyprint"><br />public class User {<br /><br />@Email<br />protected String adresse_mail;<br /><br />@Basic<br />@Column(length=50)<br />public String getAdresse_mail() {<br /> return adresse_mail;<br />}<br />public void setAdresse_mail(String adresse_mail) {<br /> this.adresse_mail = adresse_mail;<br />}<br />}<br /></pre>However there are cases where you will always like to implement your own validators. For example when you want to reach to the database and decided whether there is not already a user with a given name, or whether the student is not already signed in specified class.<br />To get more information about JSR 303 validation refer to <a href="http://www.openscope.net/2010/02/08/spring-mvc-3-0-and-jsr-303-aka-javax-validation/">this blog post.</a><br /><h4>Advanced Security Approaches</h4>When working on our application I was having hard time to find out how to force Spring Security to you my own database model and perform the authentication my way. I found that the easiest way was to implement <b>UserDetailsService</b> interface. This interface contains one method called: <b>loadUserByUsername</b> which returns <b>UserDetails</b> class, also defined by Spring. This class should contain the user information. So basically its up to you to implement this method that way, that you will give it the user name and it will return filled UserDetails class containing users password and users roles. Here is a simple implementation:<br /><br /><pre class="prettyprint"><br />@Service("userDetailsService") <br />public class UserDetailsServiceImpl implements UserDetailsService {<br /><br />  @Autowired<br />  private UsersDAO usersDAO;<br /><br />  @Transactional(readOnly = true)<br />  public UserDetails loadUserByUsername(String username)<br />      throws UsernameNotFoundException, DataAccessException {<br /><br />    User user = usersDAO.findByLogin(username);<br />    <br />    if (user == null)<br />      throw new UsernameNotFoundException("user not found");<br /><br />    Collection<grantedauthority> authorities = new ArrayList<grantedauthority>();<br />    for (openschool.domain.model.Role role : user.getRoles()) {<br />      authorities.add(new GrantedAuthorityImpl(role.getRole()));<br />    }<br />    <br />    String password = user.getPassword();<br />    boolean enabled = user.isEnabled();<br />    boolean accountNonExpired = true;<br />    boolean credentialsNonExpired = true;<br />    boolean accountNonLocked = true;<br />    <br />    <br />    org.springframework.security.core.userdetails.User springUser;<br />    springUser = new User(username, password, enabled, accountNonExpired, credentialsNonExpired, accountNonLocked, authorities);<br />    <br />    return springUser;<br />  }<br />}<br /></pre><br /><h4>Unit Tests</h4>When using Spring IOC you need to tell to spring what is the application context for the unit tests. Normally the application context is specified by the <b>web.xml</b> file. But the Unit Tests do not have anything together with the web application, so you have to tell to Spring where to find all the definitions in order to wire all you injected objects.<br />This can be done by annotating the UnitTest class by following annotations:<br /><pre class="prettyprint"><br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration(locations={"classpath:/applicationContext.xml"})<br /></pre>The ContextConfiguration annotations provides the information to spring where to find the configuration xml. Here it points to the applicationContext.xml on the classpath. Just two provide some information on how the complete test class can look:<br /><br /><pre class="prettyprint"><br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration(locations={"classpath:/applicationContext.xml"})<br />public class UsersDAOTest{<br /><br /> @Autowired<br /> UsersDAO usersDao;<br /> <br /> private Long beforeUserID;<br /> <br /> @Before<br /> @Transactional<br /> public void initDB(){<br />  Administratif user = new Administratif();<br />  user.setLastName("User_before");<br />  user.setAdresse_mail("email@email.com");<br />  user.setLogin("login");<br />  <br />  <br />  usersDao.addUser(user);<br />  beforeUserID = user.getIdUser();<br /> }<br /> <br /> @Test<br /> @Transactional<br /> public void testAddUser() {<br />  <br />  User user = new User();<br />  user.setLastName("Lastname");<br />  user.setAdresse_mail("email@email.com");<br />  <br />  usersDao.addUser(user);<br />  <br />  User user2 = usersDao.getUser(user.getIdUser());<br />  assertEquals(user, user2); <br />       }<br /></pre>You might also want to create Test Suites which allow to run multiple tests in the same time, by creating simple class with @Suite annotation:<br /><pre class="prettyprint"><br />@RunWith(Suite.class)<br />@Suite.SuiteClasses({<br /> MyTest1.class,<br /> UsersDAOTest.class,<br /> MyTest2.class<br />})<br />public class TestSuite {<br />  //intentionally empty<br />}<br /></pre>