---
layout: post
title: Mock Java Calendar - JMockit vs Mockito
date: '2012-04-03T05:12:00.000-07:00'
author: Jan Fajfr
tags:
- Java
- Testing
modified_time: '2014-06-26T14:25:09.134-07:00'
blogger_id: tag:blogger.com,1999:blog-1710034134179566048.post-5873479968341259306
blogger_orig_url: http://hoonzis.blogspot.com/2012/04/mock-java-calendar-jmockit-vs-mockito.html
---

To get the current time or day in Java, one should be using the Calendar class in the following way:<br /><br /><pre class="prettyprint"><br />Calendar c = Calendar.getInstance();<br />int day = c.get(Calendar.DAY_OF_WEEK);<br /></pre>Now I imagine this code can be hidden somewhere inside a business method and the behaviour of that method would be dependent on the current day. Typical example can be the method which returns the schedule of the cinema on the current day. <pre class="prettyprint"><br />public class ScheduleService{<br />  public Schedule getTodaySchedule(){<br />    Calendar c = Calendar.getInstance();<br />    int day = c.get(Calendar.DAY_OF_WEEK);<br /><br />    //get it from DB or wherever you want<br />    Schedule s = lookupAccordingToDay(day);<br />  }<br />}<br /></pre><p>In order to test this method you have to mock the Calendar. You will have to verify, that for monday the service will return the schedule for monday. However since the test will be automatically called every day, not only monday, you will obtain whole different schedules and the assert will fail. There are several solutions to this. I have 3 in my mind.</p><h2>Solution 1: create a separate service</h2>First solution has nothing to do with mocking. The way to go here is to isolate the Calendar into a separate service (let's call it CurrentDayService). Than you can manually create a mock for this service. You will also have to change the body of your ScheduleService to use this CurrentDayService. <pre class="prettyprint"><br />public interface ICurrentDayService {<br />   int getCurrentDay();<br />}<br /><br />public class CurrentDayService {<br />   public int getCurrentDay(){<br />      Calendar c = Calendar.getInstance();<br />      return c.get(Calendar.DAY_OF_WEEK);<br />   }<br />}<br /><br />public class CurrentDayServiceMock {<br />   private int dayToReturn;<br />   public CurrentDayServiceMock(int dayToReturn){<br />     this.dayToReturn = dayToReturn;<br />   }<br />   public int getCurrentDay(){<br />      return dayToReturn;<br />   }<br />}<br /><br />public class ScheduleService {<br />  //@Autowire or inject this service<br />  private CurrentDayService dayService;<br />  <br />  public Schedule getTodaySchedule(){<br />    int day = dayService.getCurrentDay();<br />    //get it from DB or wherever you want<br />    Schedule s = lookupAccordingToDay(day);<br />  }<br />}<br /></pre><p>Now in the unit test your schedule service, can use the mock instead of the real implementation. If you are using Dependency Injection than you can define a different context for unit tests. If not, you will have to do it manually.</p><h2>Solution 2: use Mockito</h2>Mockito allows you to mock the real <b>Calendar</b> class. That means that you no longer need to wrap the Calendar by some <b>CurrentDayService</b> class just to be able to mock the behavior. However you will still have to add a mechanism to pass the mocked Calendar to your service. That is not that complicated. Have a look at the following definition o the ScheduleService and the unit test which comes with it. <pre class="prettyprint"><br />public class ScheduleService{<br />  private Calendar calendar;<br />  public ScheduleService(){<br />    calendar = Calendar.getInstance();<br />  }<br />  public Schedule getTodaySchedule(){<br />    int day = calendar.get(Calendar.DAY_OF_WEEK);<br />    Schedule s = lookupAccordingToDay(day);<br />  }<br /><br />  public setCalendar(Calendar c){<br />    calendar = c;<br />  }<br />}<br /><br />@Test<br />public void testGetTodaySchedule() {<br /> Calendar c = Mockito.mock(Calendar.class);<br /> Mockito.when(c.get(Calendar.DAY_OF_WEEK)).thenReturn(2);<br /><br /> ScheduleService sService = new SomeStrangeService();<br /> //there has to be a way to set the current calendar<br /> sService.setCalendar(c);<br /> Schedule schedule = sService.getTodaySchedule();<br /> //Assert your schedule values<br />}<br /></pre><p>To sum it up: if the <b>setCalendar</b> method is not called, than the Calendar is instantiated in the constructor. So in production, it will return the current day. In your unit test, you can easily mock it, to specify different behavior. Tha drawback: if someone accidentaly calls the <b>setCalendar</b> method in the production, you will get into truble.</p><h2>Solution 3: use JMockit, mock all the calendars in you JVM</h2>JMockit is strong framework which as some other mocking frameworks is using the <b>Java Instrumentation API</b>. The code that you want to execute in your mocks is injected as bytecode at runtime. This enables JMockit to, for instance mock all the instances of Calendar class in your JVM. Here is how you can achieve this: <pre class="prettyprint"><br />@MockClass(realClass = Calendar.class)<br />public static class CallendarMock {<br /><br /> private int hour;<br /> private int day;<br /> private int minute;<br /><br /> public CallendarMock(int day, int hour, int minute) {<br />  this.hour = hour;<br />  this.day = day;<br />  this.minute = minute;<br /> }<br /><br /> @Mock<br /> public int get(int id) {<br />  if (id == Calendar.HOUR_OF_DAY) {<br />   return hour;<br />  }<br />  if (id == Calendar.DAY_OF_WEEK) {<br />   return day;<br />  }<br /><br />  if (id == Calendar.MINUTE) {<br />   return minute;<br />  }<br />  return -1;<br /> }<br />}<br /></pre><br />The previous code snippet is the infrastructure which I can use to mock the Calendar's <b>get</b> method. A utility class CalendarMock has to be created, which specifies the methods which are mocked. The <b>realClass</b> attribute in the MockClass annotation specifies which class is mocked by the defined class. So now the unit test is simplified. There is not need to specify the Calendar which should be used by the ScheduleService. <pre class="prettyprint"><br />@Test<br />public void testGetTodaySchedule() {<br /> Mockit.setUpMocks(new CallendarMock(Calendar.MONDAY, 12, 20));<br /> ScheduleService sService = new SomeStrangeService();<br /> Schedule schedule = sService.getTodaySchedule();<br /> //Assert your schedule values<br />}<br />@After<br />public void destroyMock() {<br />    Mockit.tearDownMocks();<br />}<br /></pre><p>At the end, you have to remember to switch-off the mocking of the Calendar. If not the Calendar will be mocked in all the tests executed after this one. Hence the call to the <b>tearDownMocks()</b> method.</p><h2>Summary</h2>With Mockito you can mock the real Calendar. However you have to pass the instance of the mocked callendar to the class, which actually uses it. With JMockit you are able to tell to the JVM: "from now all my mocks behave like this...". For me this simplifies the situation, while I am not forced to create a setter for a Calendar to be passed to my service class. But it would take much more time and effort to compare the two frameworks. It might be that Mockito handles some situations better than JMockit. <a style="display: none" href="http://www.codeproject.com/script/Articles/BlogFeedList.aspx?amid=honga" rel="tag">CodeProject</a>