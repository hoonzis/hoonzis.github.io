---
layout: post
title: DotNetOpenAuth and Url rewriting (in Azure)
date: '2011-08-17T06:01:00.000-07:00'
author: Jan Fajfr
tags:
- OAuth
- WCF
modified_time: '2014-06-26T14:51:20.727-07:00'
blogger_id: tag:blogger.com,1999:blog-1710034134179566048.post-7264593240363821929
blogger_orig_url: http://hoonzis.blogspot.com/2011/08/dotnetopenauth-and-url-rewriting-in.html
---

I have created a simple OAuth provider for my web application using DotNetOpenAuth just <a href="http:/hoonzis.blogspot.com/2011/08/using-dotnetopenauth-to-create-oauth.html">the way that I described in this last post.</a> On local everything worked just fine. However when I published the solution to Azure then I obtained errors while processing authorized request.<br /><br />Well the error happend because I used the idea of specifing exact <b>scope</b> within each token, which says what URL the consumer application has right to access. So to each Access Token a String value representing the scope is added representing the URL which the application has right to access. When the consumer application demands data from certain web service, than the Authorization Manager checks the scope of the access token which was added to the request.<br />The problem comes when the server which is hosting the OAuth data provider performs some URL rewriting. In that case the URL which is being accessed had changed in the HTTP pipeline and the provider has to take care of that. The URL of each request comming to Azure changes inside.<br /><br />If you take a look at the Authorization Manager code from the DotNetOpenAuth you will see that it checks the scope of the incoming message.<br /><pre class="prettyprint"><br />public class OAuthAuthorizationManager : ServiceAuthorizationManager<br />{<br />  protected override bool CheckAccessCore(OperationContext operationContext)<br />  {<br />    //check the access token etc...<br />    //scopes containes the scopes added to the access token<br />    if (scopes.Contains(operationContext.IncomingMessageHeaders.Action)) {<br />      return true;<br />    }<br />  }<br />}<br /></pre><br />And that is actually the problem, while <b>operationContext.IncomingMessageHeaders.Action</b> contains the URL after rewrite and the consumer application usually specifies the URL which it wants to access in the form before the rewrite.<br /><br />What I found as a solution to this issue was to use instead this piece of code<br /><pre class="brush:csharp"><br />Uri requestUri = operationContext.RequestContext.RequestMessage.Properties.Via;<br />...<br />...<br />var action = requestUri.AbsoluteUri.Substring(0, requestUri.AbsoluteUri.IndexOf("?"));<br />if (scopes.Contains(action))<br />{<br />    return true;<br />}<br /></pre>