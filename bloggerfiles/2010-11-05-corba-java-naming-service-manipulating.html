---
layout: post
title: CORBA - Java Naming Service, manipulating contexts
date: '2010-11-05T06:06:00.000-07:00'
author: Jan Fajfr
tags:
- Java
- Corba
modified_time: '2014-06-27T05:13:53.741-07:00'
thumbnail: http://3.bp.blogspot.com/_fmvjrARTMYo/TNQAvdcv8fI/AAAAAAAAAIA/j51yXl_dLBg/s72-c/nsadmin.JPG
blogger_id: tag:blogger.com,1999:blog-1710034134179566048.post-6874415143809519334
blogger_orig_url: http://hoonzis.blogspot.com/2010/11/corba-java-naming-service-manipulating.html
---

<p>This is a short post describing how to implement simple tool to manage CORBA Naming Service.</p><h3>Corba</h3><p>The aim of this paragraph is not to describe CORBA, but just to explain little bit how it works, so that later I can explain what is and how works Naming Service - which is part of the CORBA architecture.</p><p>So CORBA stands for Common Object Request Broker Architecture. It is a standard which enables programmers to write distributed applications, we can simplify it a lot and say it enables us to write apps working over the network.</p><p>Corba is just implementation of standard Server - Client architecture. In Corba's world we create objects on the Server side - and these objects can be used by the clients, which are running on another computers on the network.</p>The client has to know the structure of the object (the methods and the attributes). The objects which are created on server side and used by the clients are before described by the IDL - interface definition language. The very big advantage of Corba is that if we describe the object by IDL we can later generate Java code as well as C++ code.<br /><br />When the server creates the object it will put its reference to ORB - Object Request Broker. This is the container that takes care of serialization of object over the network. This is the abstraction layer which permits us to run distributed apps. When the Server submits the object to ORB, it will obtain IOR - string identification of the object reference in ORB.<br /><br />When the client wants to access the object it will need the IOR. If the server and client meet before they can somehow exchange this info - if not we need to transfer the IOR a different way. Here we will use Naming Service.<br /><br /><h3>Naming Service</h3>Naming Service is a tree structure which allows to store object references of objects which are being managed by the Object Request Broker. Basically that means that the client can now access the object not only by its IOR - but also by a string like name of the object.<br /><br />Naming Service is a tree structure. There are generally 2 types of nodes - contexts and object references. When a node is a context it can contain several children - this can be again of type context or object. When the client wants an object reference, he needs to now the exact place of the object reference in the tree structure and its name.<br />There is some valuable information about CORBA Naming Service on <a href="http://download.oracle.com/javase/1.4.2/docs/guide/idl/jidlNaming.html#startingnameserver">this site.</a><br /><br /><h3>NSAdmin</h3>The tool which I called NSAdmin allows creating or deleting references to objects as well as creating and destroying contexts. The tool can visualise the tree structure using the Java JTree component. Here is how it looks like:<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/_fmvjrARTMYo/TNQAvdcv8fI/AAAAAAAAAIA/j51yXl_dLBg/s1600/nsadmin.JPG" imageanchor="1" style="margin-left:1em; margin-right:1em"><img border="0" height="220" width="320" src="http://3.bp.blogspot.com/_fmvjrARTMYo/TNQAvdcv8fI/AAAAAAAAAIA/j51yXl_dLBg/s320/nsadmin.JPG"></img></a></div><h3>How it works</h3>I wrote NSAdmin in Java and I have used SWING to create the GUI. The program is composed of two classes NSAdminFrame (the GUI) and NSAdmin a static class which actually contains the implementations of the methods. To test the tool you can use the Java implementation of ORB which is a generic part of JDK. To start ORB run:<br /><b>orbd.exe -ORBInitialPort 1234</b><br /><h3>The initialisation</h3>In order to work with the Naming Service we have to initialize the Object Request Broker. From the ORB we can obtain the reference to root naming context. This context is always called "NameService". The method for initialization looks like this, if you have started the ORB on your local machine, than the parametrs that you will submit to this method will be: 1234,localhost. Note that the variable <b>rootContext</b> and <b>orb</b> are defined on top of the static class.<br /><pre class="prettyprint"><br />public static void init(String port, String initialHost) throws Exception{ <br />  String[] args = new String[4]; <br />  args[0] = "-ORBInitialPort"; <br />  args[1] = port; <br />  args[2] = "-ORBInitialHost"; <br />  args[3] = initialHost; <br /> <br />  orb = ORB.init(args,null); <br />  rootContext = NamingContextExtHelper.narrow(orb.resolve_initial_references("NameService")); <br />} <br /></pre><h3>Exploring the Naming Service tree</h3>To list the content of the naming context we have a method which recursively calls itself. This method will create a tree structure of classes which I called Entry.<br /><br />Entry is a simple class which has a name and can have multiple childern in its ArrayList entries.<br /><pre class="prettyprint"><br />public class Entry {<br /> public ArrayList<entry> entries;<br /> <br /> public String name;<br /> <br /> public Entry(String n){<br />  name = n;<br />  entries = new ArrayList<entry>();<br /> }<br />}<br /></pre><p>The structure of Entry classes will be later used to visualise the content in JTree. OK now the method <b>explore</b> which recursivelly traverses the naming context.</p><pre class="prettyprint"><br />public static Entry explore(String contextName,NamingContext context,int treeDepth) throws InvalidName, NotFound, CannotProceed, org.omg.CosNaming.NamingContextPackage.InvalidName{<br />  <br />  BindingListHolder blh = new BindingListHolder();<br />  BindingIteratorHolder bih = new BindingIteratorHolder();<br />  <br />  context.list(0,blh, bih);<br />  <br />  Entry entry = new Entry(contextName);<br />  <br />     System.out.println(contextName); <br />  //binding iterator<br />  BindingIterator bit = bih.value;<br />  <br />  boolean remains = true;<br />  while(remains){<br />   BindingHolder biholder = new BindingHolder();<br />   remains = bit.next_one(biholder);<br />   Binding binding = biholder.value;<br />   <br />   NameComponent[] name = binding.binding_name;<br />   <br />   <br />   if(binding.binding_type == BindingType.nobject){<br />    if(name.length == 1){<br />     System.out.println("ID: " + name[0].id + " KIND: " + name[0].kind + " Depth: " + treeDepth);<br />     entry.entries.add(new Entry(name[0].id));<br />    }<br />   }else if(binding.binding_type == BindingType.ncontext){<br />    NamingContext tmpContext =  NamingContextHelper.narrow(context.resolve(binding.binding_name));<br />    NameComponent component = name[0];<br />    entry.entries.add(explore(component.id,tmpContext,treeDepth+1));<br />   }<br />  }<br />  return entry;<br /> }<br /></pre><p>The methdo takes <b>NamingContext</b> as parametr and will return a structure of Entry classes which will corespond to the naming service tree. There are couple thinks to notice:<br />The method <b>list(int,BindingListHolder, BindingIteratorHolder)</b> has two ways of usage. The first posibility is to specify how many binding we want to load. If we specify the value, than the bindings will be loaded into the array <b>Binding[]</b> which will be returned in the BindingListHolder class.</p><p>The second possibility is to call <b>list(0,blh,bih)</b>. This way the BindingListHolder will contain no results and we will obtain an iterator which we can use to iterate through the array. That is the posibility which I chosed.</p>You can see that I iterate through all the bindings and for each binding I determine the type. If it is a context - than I will recursively explore the context, if the type is object(reference is binded) than I will just add new Entry which will represent this reference.<br /><h3>Destroying and Creating a subcontext</h3>Creating the context is quite straight forward.<br /><pre class="prettyprint"><br />public static void createContext(String name) throws org.omg.CosNaming.NamingContextPackage.InvalidName, NotFound, CannotProceed, AlreadyBound{<br />  <br />  NameComponent[] contextName = rootContext.to_name(name);<br />  NamingContext newContext = rootContext.new_context();<br />  rootContext.bind_context(contextName,newContext);<br /> }<br /></pre>Destroying context can be a bit tricker because in order to destroy a context, the context has to be empty. So I implemented a recursive method, which will destroy all the children of context and than the context can be destroyed.<br /><br /><pre class="prettyprint"><br />public static void deleteContext(String name) throws org.omg.CosNaming.NamingContextPackage.InvalidName, NotFound, CannotProceed, NotEmpty{<br />  NameComponent[] contextName = rootContext.to_name(name);<br />  NamingContext context = NamingContextHelper.narrow(rootContext.resolve(contextName));<br />  <br />  BindingListHolder blh = new BindingListHolder();<br />  BindingIteratorHolder bih = new BindingIteratorHolder();<br />  context.list(Integer.MAX_VALUE, blh, bih);<br />  <br />  for(Binding binding:blh.value){<br />   NameComponent[] componentName = binding.binding_name;<br />   if(binding.binding_type == BindingType.ncontext){<br />    NSAdmin.deleteContext(name + "/" + componentName[0].id);<br />   }<br />   else{<br />    NSAdmin.deleteObjectReference(name + "/" + componentName[0].id);<br />   }<br />  }<br />  <br />  context.destroy();<br />  rootContext.unbind(contextName);<br /> }<br /></pre><h3>Creating object reference</h3>This last method is a method to manually add object reference to a context. Let say that an object was created on the server and we have the IOR - the Interoperable Object Reference - which is a identificator of the object. Well than we can bind the reference of the object to the tree and a client application can use just the name to obtain the reference.<br /><br /><pre class="prettyprint"><br />public static void createObjectReference(String ior,String context,String objectName) <br /> throws org.omg.CosNaming.NamingContextPackage.InvalidName, NotFound, CannotProceed, AlreadyBound{<br />  org.omg.CORBA.Object reference=orb.string_to_object(ior);<br />  NameComponent[] componentName = rootContext.to_name(context + objectName);<br />  rootContext.bind(componentName,reference);<br /> }<br /></pre>To obtain the reference of the object we just call the method <b>string_to_object</b> of Object Request Broker. The actual binding is than performed as for any other object we want to bind in the tree.<br /><h3>Summary</h3>This is just a light overview of the functions which are the core of the program. Of course there is a bit of glue code to put it together and let it work with the GUI. I thinks you can easily understand the rest from the code itself.<br /><a href="http://www.codeproject.com/script/Articles/BlogFeedList.aspx?amid=honga" rel="tag" style="display:none">CodeProject</a>