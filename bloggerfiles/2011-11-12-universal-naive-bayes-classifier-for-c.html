---
layout: post
title: Universal Naive Bayes Classifier for C#
date: '2011-11-12T12:46:00.001-08:00'
author: Jan Fajfr
tags:
- Machine Learning
- C#
- Computer Science
modified_time: '2014-06-26T14:43:58.259-07:00'
blogger_id: tag:blogger.com,1999:blog-1710034134179566048.post-39794529233766945
blogger_orig_url: http://hoonzis.blogspot.com/2011/11/universal-naive-bayes-classifier-for-c.html
---

This post is dedicated to describe the internal structure and the possible use of Naive Bayes classifier implemented in C#.<br /><br />I was searching for a machine learning library for C#, something that would be equivalent to what WEKA is to Java. I have found <a href="http://machine.codeplex.com">machine.codeplex.com</a> but it did not include the Bayesian classification (the one in which I was interested). So I decided to implement it into the library.<br /><h3>How to use it</h3>One of the aims of <a href="http://machine.codeplex.com">machine.codeplex.com</a> is to allow the users to use simple POCO's for the classification. This can be achieved by using the C# attributes. Take a look at the following example which treats categorization of payments, based on two features: Amount and Description.<br />First this is the Payment POCO object with added attributes:<br /><pre class="prettyprint"><br />public class Payment<br />{<br />    [StringFeature(SplitType = StringType.Word)]<br />    public String Description { get; set; }<br /><br />    [Feature]<br />    public Decimal Amount { get; set; }<br /><br />    [Label]<br />    public String Category { get; set; }<br />}<br /></pre>And here is how to train the Naive Bayes classifier using a set of payments and than classify new payment.<br /><pre class="prettyprint"><br />var data = Payment.GetData();            <br />NaiveBayesModel&lt;Payment&gt; model = new NaiveBayesModel&lt;Payment&gt;();<br />var predictor = model.Generate(data);<br />var item = predictor.Predict(new Payment { Amount = 110, Description = "SPORT SF - PARIS 18 Rue Fleurus" });<br /></pre><br />After the execution the <b><i>item.Category</b></i> property should be set to a value based on the analysis of the previously supplied payments.<br /><br /><h3>About Naive Bayes classifier</h3>This is just small and simplify introduction, refer to the <a href="http://en.wikipedia.org/wiki/Naive_Bayes_classifier">Wikipedia article</a> for more details about Bayesian classification.<br /><br />Naive Bayes is a very simple classifier which is based on a simple premise that all the features (or characteristics) of classified items are independent. This is not really true in the real life, that is why the model is called naive.<br />The total probability of a item having features F1, F2, F3 being of category "C1" can be expressed as:<br /><br /><b>p(F1,F2,F3|C1) = P(C1)*P(F1|C1)*P(F2|C1)*P(F3|C1)</b><br /><br />Where P(C1) is the <b>A priory</b> probability of item being of category C1 and P(F1|C1) is the <b>Posteriori</b> probability of item being of category C1 when it has feature F1.<br />That is simple for binary features (like "Tall", "Rich"...). For example p(Tall|UngulateAnimal) = 0.8, says that the posteriori probability for an animal to be and ungulate is 0.8, when it is a tall animal.<br /><br />If we have continuous features (just like the "Amount" in the payment example), the Posteriori probability will be expressed slightly differently. For example P(Amount=123|Household) = 0.4 - can be translated as: the probability of the payment being part of my household payments is 0.4, when the amount was 123$.<br /><br />When we classify, we compute the total probability for each category (or class if you want) and we select the category with maximal probability. We have to thus iterate over all the categories and all the features of each item and multiply the probabilities to obtain the probability of the item being in each class.<br /><br /><h3>How it works inside</h3>After calling the <b><i>Generate</b></i> method on the model a <b><i>NaiveBayesPredictor</b></i> class is created. This class contains the <b><i>Predict</b></i> method to classify new objects.<br />My model can work with three types of features (or characteristics, or properties):<br /><ul><li>String properties. These properties have to be converted to a binary vectors based on the words which they contain. The classifier builds a list of all existing words in the set and then the String feature can be represented as a set of binary features. For example if the bag of all worlds contains four words: (Hello, World, Is, Cool), than the following vector [0,1,0,1] represents text "World Cool".</li><li>Binary properties. Simple true or false properties</li><li>Continuous properties. By default these are Double or Decimal values, but the list could be extend to other types.</li></ul>After converting the String features to binary features, we have two types of features:<br /><ul><li>Binary features</li><li>Continuous features</li></ul>As mentioned in the introduction for each feature in the item we have to compute the A priori and Posteriori probabilities. The following pseudocode shows how to estimate the values of A priori and Posteriori probabilities. I use array-like notation, just because I have used arrays also in the implementation.<br /><br /><h3>Apriori probability</h3>The computation of Apriori probability will be the same for both type of features.<br /><br /><b>Apriori[i] = #ItemsOfCategory[i] / #Items</b><br /><br /><h3>Posteriori probability</h3>The Posteriori for binary features will be estimated:<br /><br /><b>Posteriori[i][j] = #ItemsHavingFeature[j]AndCategory[i] / #ItemsOfCategory[i]</b><br /><br />And the Posteriori probability for contiunous features:<br /><br /><b>Posteriori[i][j] = Normal(Avg[i][j],Variance[i][j],value)</b><br /><br />Where <b>Normal</b> references the <a href="http://en.wikipedia.org/wiki/Normal_distribution">normal probability distribution</a>. Avg[i][j] is the average value of feature "j" for items of category "i". Variance[i][j] is the <a href="http://en.wikipedia.org/wiki/Variance">variance of feature</a> "j" for items of category "i".<br />If we want to know the probability of payment with Amount=123 being of category "Food", we have the average of all payments of that category let's say: Avg[Food][Amount] = 80, and we have the Variance[Food][Amount] = 24, then the posteriori probability will be equal: Normal(80, 24, 123).<br /><br /><h3>What does the classifier need?</h3>The response to this question is quite simple, we need at least 4 structures, the meaning should be clear from the previous explication.<br /><br /><pre class="prettyprint"><br />public double[][] Posteriori { get; set; }<br />public double[] Apriori { get; set; }<br />public double[][] CategoryFeatureAvg { get; set; }<br />public double[][] CategoryFeatureVariance { get; set; }<br /></pre><h3>And how does it classify?</h3>As said before the classification is a loop for all the categories in the set. For each category we compute the probability by multiplying apriori probability with posteriori probability of each feature. As we have two types of features, the computation differs for both of them. Take a look at this quite simplified code:<br /><br /><pre class="prettyprint"><br />public T Predict (T item){<br />  Vector values; // represents the item as a vector<br />  foreach (var category in Categories)<br />  {<br />      for (var feature in Features)<br />      {<br />          if (NaiveBayesModel&lt;t&gt;.ContinuesTypes.Contains(feature.Type))<br />          {<br />              var value = values[feature];<br />              var normalProbability = Helper.Gauss(value, CategoryFeatureAvg[category][j], CategoryFeatureVariance[category][j]);<br />              probability = probability * normalProbability;<br />          }<br />  <br />          if (feature.Type == typeof(bool)) //String properties are converted also to binary<br />          {<br />              var probabilityValue = Posteriori[category][j];<br />          }<br />      }<br />  <br />      if (probability &gt; maxProbability)<br />      {<br />          maxProbability = probability;<br />          maxCategory = category;<br />      }<br />  }<br />  item.SetValue(maxCategory);<br />}<br /><br /></pre><br />That's all there is to it. Once you understand that we need just 4 arrays, it is just a question of how to fill these arrays, that is not hard (it should be clear from the previous explication), but it takes some plumbing and looping over all the items in the learning collection.<br />If you would like to see the Source Code - check my fork <a href="http://machine.codeplex.com/SourceControl/network/Forks/hoonzis/NaiveBayes">machine.codeplex.com</a>.