---
layout: post
title: Charting with Fable and NVD3
date: '2016-04-16T05:25:00.000-08:00'
author: Jan Fajfr
tags:
- Maps
modified_time: '2016-04-16T05:11:43.965-08:00'
---
Recently I came across [Fable](http://fable.io/). Fable transpiles F# code into JavaScript, so you can run your F# in the browser. It will also generate map files, so that you can even debug F# in the browser and the generated JS is actually very readable so if something goes wrong you can still look to the "compiled" code. To sum it up, it's really a great project and I was amazed on how few modifications were necessary to my code to make it compile into JS. I am working on a small application to visualize some financial data and I figured out it would be great to use Fable for this. So I set myself to make Fable work with [NVD3](https://github.com/novus/nvd3) and draw some interesting charts.

### Installing Fable
Fable is a compiler, so you might expect an executable. In this case it comes bundled as **npm** package, which you might want to install globally:

```
npm install -g fable-compiler
```

### Setup the Fable project
Before you get started with any code, you have to consider few things:

* Are you going to fit everything into single F# file or you will create a project? Fable allows you to do both and in the simpliest situation I will just point fable to a single file, but if you plan to build something bigger, you better create F# project (F# library will work, even though you won't distribute anything as library but compile into JS instead).

* How the resulting JavaScript should be structured and packaged? Two most common ways of defining modules in JavaScript are AMD and CommonJS.

* How is the resulting JS bundled. Fable will create one JavaScript file per F# file, these files have to be then loaded by the browser. Depending on the module pattern (CommonJS vs AMD) you will have to bundle them together to a single JavaScript file which will be included in the html.

I have chosen the following setup: F# project with multiple files. CommonJS as module system, bundled with Webpack. To go for this configuration, you will have to create the following 3 files in the root of the project folder:

**package.json**  - will define your JavaScript project (standard Node project), here you can list the necessary packages that you depend on.

```json
{
  "private": false,
  "name": "fabled-pricer",
  "version": "1.0.0",
  "main": "index.js",
  "author": "Jan Fajfr",
  "license": "MIT",
  "dependencies": {
    "core-js": "^2.4.0",
    "d3": "^3.5.17",
    "fable-core": "0.6.6",
    "nvd3": "^1.8.4",
  },
  "engines": {
    "fable": ">=0.2.11"
  },
  "devDependencies": {
    "source-map-loader": "^0.1.5",
    "webpack": "^1.13.2"
  }
}
```

**fableconfig.json** - Fable's configuration - tell fable what are his dependencies, which JavaScript module system should be used.

```json
{
  "module":  "commonjs",
  "sourceMaps": true,
  "projFile": "Pricer.Fabled.fsproj",
  "outDir": "CompiledJs/Pricer.Fabled",
  "scripts": {
    "postbuild": "webpack"
  },
  "targets": {
    "watch": {
      "scripts": {
        "postbuild": "webpack --watch"
      }
    }
  }
}
```

**webpack.config.json** - Webpack's config, tell him where the JS files are (generated by fable) and where to output the bundled result

```javascript
module.exports = {
    entry: {
        chartingTest: "./CompiledJs/Pricer.Fabled/ChartingTest"
    },
    output: {
        filename: "[name].bundle.js",
        path: "./out"
    },
    devtool: "source-map",
    module: {
        preLoaders: [{
            loader: "source-map-loader",
            exclude: /node_modules/,
        }],
    },
    externals: {
        "d3": "d3"
    }
};
```

### Creating the web page
The page itself will be very small - it contains only one div tag which we will use to draw the chart. We also have to reference all JavaScript libraries on which we are depending and finally the JavaScript compiled from our F# code.

### The F# application
Let's look at the content of "main" file. The file contains a single module, with a single function that is invoked. This function will be called when the JavaScript is loaded.

```ocaml
namespace Pricer.Fabled

open System

module ChartingTest =

    let random = new Random()

    let randomValues() =
        [|1 .. 10|] |> Array.map (fun i ->
        {
            x = new DateTime(2014, i, 1)
            y = float (random.Next() / 100000)
            size = float (random.Next())
        })

    let drawChart() =
        let series = [|
                {
                    key = "Series 1"
                    values = randomValues()
                };
                {
                    key = "Series 2"
                    values = randomValues()
                }
            |]

        Charting.drawScatter series "#chart"

    drawChart()
```

All we are doing here is preparing the data for the charting. We will generate an array of items for the scatter chart. Each item has three properties (x,y,size). Then we will wrap all the data into two series and pass to the drawing function. Note that nothing is said here about the types of the values, but the standard NVD3 JavaScript code would look very similar. You can look at the [official scatter chart example](https://github.com/nvd3-community/nvd3/blob/gh-pages/examples/scatterChart.html). We will look into the details of **drawScatter** method later.

### Writing typed definitions for NVD3
In the previous snippet we have created an array of "Series" with two Series of random data. The shape of the series reflects what NVD3 is expecting, but since we are compiling from F# we have to define the types that would resemble to what NVD3 is expecting. That is really not that hard, these 2 records will do:

```ocaml
type DateScatterValue = {
    x: DateTime
    y: float
    size: float
}

type Series<'a> = {
    key: string
    values: 'a array
}
```

These are not all the types that we will need, but the rest will be much clearer if we look at the function that draws the data.

### Drawing the charts
Our drawing function takes two parameters. First the data to draw and a selector which will tell us to which element in the HTML page we should draw the chart. The content will again resemble a lot a JavaScript NVD3 [official scatter chart example](https://github.com/nvd3-community/nvd3/blob/gh-pages/examples/scatterChart.html).

```ocaml
let drawScatter (data: Series<DateScatterValue> array) (chartSelector:string) =
    let colors = D3.Scale.Globals.category10()
    let chart = nv.models.scatterChart().pointRange([|10.0;800.0|]).showLegend(true).showXAxis(true).color(colors.range())
    chart.yAxis.axisLabel("Strike") |> ignore
    chart.xAxis.axisLabel("Expiry") |> ignore
    let chartElement = D3.Globals.select(selector);
    chartElement.html("") |> ignore
    chartElement.style("height","500px") |> ignore
    chartElement.datum(data).call(chart) |> ignore
```

This function calls two libraries: NVD3 and D3 itself. There is however a small diference. For any NVD3 code that we call, we have to define the F# types, so that F# compiler is not confused, and Fable "knows" that it can just output the code itself. For D3 however we can use the [Fable D3 Bindings](https://www.npmjs.com/package/fable-import-d3) which are available as npm package. That basically means that for instance **D3.Scale.Globals.category10** has been defined in the D3 bindings DLL and Fable knows that the correct JavaScript output is **d3.scale.category10()**, without us telling him.

For NVD3, we have to defined the bindings manually. So let's start with the call to **nv.models.scatterChart**

```ocaml
module nv =
    let models: ChartModels = failwith "JS only"

type ChartModels =
    abstract lineChart: unit -> LineChart
    abstract scatterChart: unit -> ScatterChart
```

So we have defined **nv** model with **models** field, this will make F# compiler happy. And fable will just output the same code in JavaScript. ChartModels is a type that provides all the charts. Our example is using only **scatterChart** but I have defined also **lineChart** just to let you know the whole idea behind this:

```ocaml
[<AbstractClass>]
type Chart() =
    abstract xAxis: Axis
    abstract yAxis: Axis
    abstract showLegend: bool -> Chart
    abstract showXAxis: bool -> Chart
    abstract showYAxis: bool -> Chart
    abstract color: string[] -> Chart

[<AbstractClass>]
type LineChart() = inherit Chart()
        with member __.useInteractiveGuideline (value:bool): Chart = failwith "JSOnly"

[<AbstractClass>]
type ScatterChart() = inherit Chart()
    with member __.pointRange(value: double array): ScatterChart = failwith "JSOnly"
```

**ScatterChart** and **LineChart** both inherit from the base **Chart** type. We also have to define the Axis:

```ocaml
type Axis =
    abstract axisLabel: string -> Axis
    abstract tickFormat: System.Func<Object,string> -> Axis
```

Writing these binding for any library becomes very easy once you understand that your are just defining interfaces and abstract classes - no implementation. You just have to make F# compiler happy and be sure that the underlying JavaScript calls will be available.

### Emitting custom JavaScript
Fable allows you to interact with JavaScript with few different ways. One way is to define function calls that will emit specific JavaScript code. Here is the official example:

```ocaml
open Fable.Core

[<Emit("$0 + $1")>]
let add (x: int) (y: string): float = jsNative

let result = add 1 "2"
```

This can be very useful sometimes. You might get into situations when it becomes hard to write code that would satisfy all the bindings and the JavaScript "reality". For example you might want to use D3 Time formatting capabilities to shape the **Axis** ticks into something readable. In JavaScript you would do something like this (very straightforward):

```javascript
chart.xAxis.tickFormat(d3.time.format("%x"));
```

NVD3 has **tickFormat** method available on all Axis, which in JavaScript takes a function transforming anything into string representation of what is shown on the axis. The signature in F# would be something like: tickFormat(Object -> string). Fable D3 bindings make the D3 Time Format available as a global module (D3.Time.Globals.format()), so one would expect something like this to work:

```ocaml
chart.xAxis.tickFormat(D3.Time.Globals.format("%x"))
```

That's not really how things works since what you get is a D3.Time.Format object not compatible with the Object->string function. That object however has **Invoke** method that takes DateTime. So you might try something like this:

```ocaml
chart.xAxis.tickFormat(fun x -> D3.Time.Globals.format("%x").Invoke(x))
 ```

Well still no luck since **Invoke** method expects DateTime and you are passing in an Object. The problem is that if you fire up Chrome debugger, you will see that in reality NVD3 won't pass into the **tickFormat** function **Date** values but instead the number of ticks as integer, representing the Date value. So you might want to try the DateTime(int numberOfTicks) constructor which should create a DateTime instance from number of ticks - but this one is not supported by Fable.

Here there is no way around than use custom function that will emit the correct JavaScript to construct a new Date which one can than pass safely to the D3 Time Format.

```ocaml
[<Emit("new Date($0)")>]
let fromTicks (ticks: int): DateTime = jsNative

let timeFormat = D3.Time.Globals.format("%x")
chart.xAxis.tickFormat(fun ticks ->
    let dateValue = DateUtils.fromTicks(ticks :?> int)
    timeFormat.Invoke(dateValue)
)
```

Note that the cast **ticks:?> int** is here really just to make F# compiler happy. The cast won't have any impact on generated JavaScript, since JS does not have types, but in the F# world, x is an Object and the function that creates the Date object takes number of ticks takes integer parameter.

So here we are really just forcing Fable to output reasonable JavaScript and giving the F# enough information to build the code.
