---
layout: post
title: Mocking the generic repository
date: '2012-05-02T13:40:00.001-07:00'
author: Jan Fajfr
tags:
- ".NET"
- Testing
- NHibernate
- C#
modified_time: '2014-06-26T14:20:01.298-07:00'
blogger_id: tag:blogger.com,1999:blog-1710034134179566048.post-6294818593906360547
blogger_orig_url: http://hoonzis.blogspot.com/2012/05/mocking-generic-repository.html
---

This post describe one way to mock the generic repository. It assumes that you are familiar with the <b>Service <-> Repository <-> Database</b> architecture. <br/>Another pre-requisity is the knowledge of the <a href="">repository pattern</a> and <a href="http://www.tugberkugurlu.com/archive/generic-repository-pattern-entity-framework-asp-net-mvc-and-unit-testing-triangle">it's generic variant</a>. <br/><br/>In the majority of my projects I am using the following generic repository class. <pre class="prettyprint"><br />public interface IRepository<br />{<br /> T Load&lt;T&gt;(object id);<br /> T Get&lt;T&gt;(object id);<br /> IEnumerable&lt;T&gt; Find&lt;T&gt;(Expression&lt;Func&lt;T, bool&gt;&gt; matchingCriteria);<br /> IEnumerable&lt;T&gt; GetAll&lt;T&gt;();<br /> void Save&lt;T&gt;(T obj);<br /> void Update&lt;T&gt;(T obj);<br /> void Delete&lt;T&gt;(T obj);<br /> void Flush();<br /> int CountAll&lt;T&gt;();<br /> void Evict&lt;T&gt;(T obj);<br /> void Refresh&lt;T&gt;(T obj);<br /> void Clear();<br /> void SaveOrUpdate&lt;T&gt;(T obj);<br />}<br /><br /></pre>Based on this technique, some people decide to implement concrete classes of this interface (<b>CarRepository : IRepository<Car></b>), whereas others decide to keep using the generic implementation. That depends on the ORM that you are using. <a href="http://elegantcode.com/2009/12/15/entity-framework-ef4-generic-repository-and-unit-of-work-prototype/">With EF</a> and <a href="http://stackoverflow.com/questions/2587965/using-a-generic-repository-pattern-with-fluent-nhibernate">NHibernate</a> you can easily implement the generic variant of the repository (check the links). <br/><br/>I am also using the generic variant (mostly with NHibernate). Now the question is: <b>How to mock this generic repository</b>? It can be a bit tricky to mock. When you have one class for each repository which works for one concrete type you can mock the repository quite easily. For example StudentRepository which handles entities of type Student might be backed up a list of students. <br/><br/>While when working with generic repository, it might be a bit harder. Here is how I have solved the problem: <pre class="prettyprint"><br />public class MockedRepository :IRepository<br />{<br /> public MockedRepository()<br /> {<br />  cities = DeserializeList&lt;City&gt;("CityDto");<br />  stations = DeserializeList&lt;Station&gt;("StationDto");<br />  tips = DeserializeList&lt;InformationTip&gt;("InformationTipDto");<br />  countries = DeserializeList&lt;Country&gt;("CountryDto");<br />  <br />  dataDictionary = new Dictionary&lt;Type, object&gt;();<br />  dataDictionary.Add(typeof(City), cities);<br />  dataDictionary.Add(typeof(Station), stations);<br />  dataDictionary.Add(typeof(InformationTip), tips);<br />  dataDictionary.Add(typeof(Country), countries);<br />  }   <br /><br /> public T Get&lt;T&gt;(object id)<br /> {<br />  Type type = typeof(T);<br />  var data = dataDictionary[type];<br />  IEnumerable&lt;T&gt; list = (IEnumerable&lt;T&gt;)data;<br />  var idProperty = type.GetProperty("Id");<br />  return list.FirstOrDefault(x=&gt;(int)idProperty.GetValue(x,null) == (int)id);<br /> }<br /><br /> public IEnumerable&lt;T&gt; Find&lt;T&gt;(Expression&lt;Func&lt;T, bool&gt;&gt; matchingCriteria)<br /> {<br />  Type type = typeof(T);<br />  var data = dataDictionary[type];<br />  IEnumerable&lt;T&gt; list = (IEnumerable&lt;T&gt;)data;<br />  var matchFunction = matchingCriteria.Compile();<br />  return list.Where(matchFunction);<br /> }<br /><br /> public IEnumerable&lt;T&gt; GetAll&lt;T&gt;()<br /> {<br />  Type type = typeof(T);<br />  return (IEnumerable&lt;T&gt;)dataDictionary[type];<br /> }<br /><br /> public void Save&lt;T&gt;(T obj)<br /> {<br />  Type type = typeof(T);<br />  List&lt;T&gt; data = (List&lt;T&gt;)dataDictionary[type];<br />  data.Add(obj);<br /> }<br />}</pre>The main building block of this mocked repository is the dictionary which contains for each type in the repository the enumerable collection of objects.  Each method in the mocked repository can use this dictionary to determine which is the collection addressed by the call (by using the generic type T.). <pre class="prettyprint"><br />Type type = typeof(T);<br />var data = dataDictionary[type];<br />IEnumerable&lt;T&gt; list = (IEnumerable&lt;T&gt;)data;<br /></pre>Now what to do next, depends on each method. I have shown here only the methods which I needed to mock, but the other ones should not be harded to mock. The most interesting is the <b>Find</b> method, which takes as the parameter the matching criteria. In order to pass this criteria to the <b>Where</b> method on the collection, this criteria (represented by an Expression) has to be compiled into a predicate Func<T,bool> (in other words function which takes an object of type T and returns boolean value. <br/><br/>The <b>Get</b> also has some hidden complexity. In this implementation I assume, that there is a <b>Id</b> property defined on the object of type T. I am using reflection to obtain the value of that property and the whole thing happens inside the a LINQ statement. <br/><br/>This repository might be useful, but it is definitely not the only way to isolate your database. So the question is - <b>Should this be the method to isolate my Unit or Integration tests?</b> Let's take a look at other possible options: <br/><br/><ul><li><b>Use mocking framework (<a href="http://stackoverflow.com/questions/37359/what-c-sharp-mocking-framework-to-use">there is quite a choice here</a>)</b><br/> This essentialy means that in each of your tests you define the behaviour of the repository class. This requires you to write a mock for each repository method that is called inside the service method. So it means more code to write. On the other hand you controll the behaviour needed for the particular tested method. While using mocking framework you have also the option to verify that methods have been caled.</li><li><b>Use the repository implementation and point it to in-memmory database</b> (SQL Lite). That is a good option in the case when: <ul><li>You are able to populate the database with the data.</li><li>You are sure of your repository implementation</li></ul></li><li><b>Use the generic repository mock presented here.</b> That is not a bad option if you have some way to populate the collections which serve as in-memmory database. I have used deserialization from JSON. Another option could be to use a framework such as <a href="http://autopoco.codeplex.com/">AutoPoco </a>to generate the data. You can also create one repository which can be used for the whole test suite (or application presentation).</li></ul><h3>Summary</h3>As said before this might be a variant to consider. I am using it for Proof of Concepts and portable versions of database based applications. On the other hand for unit test you might consider either mocking framework or in-memory database. There is no clear winner in this comparison. <a style="display: none" href="http://www.codeproject.com/script/Articles/BlogFeedList.aspx?amid=honga" rel="tag">CodeProject</a>