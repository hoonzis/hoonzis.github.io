---
layout: post
title: Silverlight Event Calendar
date: '2011-06-26T12:45:00.001-07:00'
author: Jan Fajfr
tags:
- Silverlight
modified_time: '2014-06-26T15:01:20.744-07:00'
thumbnail: http://2.bp.blogspot.com/-7bC4PEIU4bg/TgBYmhQJ5CI/AAAAAAAAAL0/fLewf14ICZQ/s72-c/EventCalendar.PNG
blogger_id: tag:blogger.com,1999:blog-1710034134179566048.post-1362817029301735257
blogger_orig_url: http://hoonzis.blogspot.com/2011/06/silverlight-event-calendar.html
---

For one of my latest project I needed a quite simple Event Calendar component for Silverlight. I did not want to use any third party libraries and I wanted this component to stay simple.<br /><br />I had following contraints on the component:<br /><ul><li>It has to be bindable</li><li>It should accept any IEnumerable collection</li><li>I should be able just specify which property of objects in the collection holds the DateTime value, which will be used to place the objects in the calendar</li><li>It should expose a template to be able to change the view of the event</li><li>It should expose events such as "Calendar Event Clicked"</li><li>It should expose a SelectedItem property</li></ul><br />Here is the resulting component - it does not look great, but you can easily style it as you want.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-7bC4PEIU4bg/TgBYmhQJ5CI/AAAAAAAAAL0/fLewf14ICZQ/s1600/EventCalendar.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="156" src="http://2.bp.blogspot.com/-7bC4PEIU4bg/TgBYmhQJ5CI/AAAAAAAAAL0/fLewf14ICZQ/s320/EventCalendar.PNG" width="320" /></a></div><a href="https://github.com/hoonzis/SilverlightEventCalendar"><b><br />You can get the code here from GitHub</b><br /></a><br />The component is based on Calendar component. Calendar is not really flexible component but there are some workarounds to make it work the way, that you like. First the calendar is placed inside a UserControl.<br /><br /><pre class="prettyprint"><br />&lt;usercontrol x:class="EventCalendarLibrary.EventCalendar"&gt;<br />    &lt;grid background="White" x:name="LayoutRoot"&gt;<br />        &lt;controls:calendar x:name="InnerCalendar"&gt;<br />    &lt;/controls:calendar&gt;&lt;/grid&gt;<br />&lt;/usercontrol&gt;<br /><br /></pre><br /><b>Calendar</b> component is composed of <b>CalendarDayButtons</b>. <b>CalendarDayButton</b> resides in the <b>System.Windows.Controls.Primitives</b><br />namespace.<br /><br />The problem is that the Calendar does not hold a collection of these buttons so we are not able to dynamically add components to these Buttons.<br /><br />However the style of the each button in the calendar can be set by setting the <b>CalendarDayButtonStyle</b> property.<br /><br />We can use this style to override the control template and this way set our proper handler for Loaded and Click events. The handler for Loaded event will simply allow us to add the loaded Button to a collection which we will maintain inside our components and which later allows us to add the "events" to the calendar.<br /><br /><pre class="prettyprint"><br />&lt;grid.resources&gt;<br />&lt;style targettype="controlsPrimitives:CalendarDayButton" x:key="CalendarDayButtonStyle"&gt;<br />            &lt;setter Property="Template"&gt;<br />                &lt;Setter.Value&gt;<br />                    &lt;controltemplate TargetType="controlsPrimitives:CalendarDayButton"&gt;<br />                        &lt;border BorderBrush="#FF598788" BorderThickness="1,1,1,1" CornerRadius="2,2,2,2"&gt;<br />                            &lt;stackpanel HorizontalAlignment="Stretch" VerticalAlignment="Stretch" MinHeight="30" MinWidth="10"&gt;<br />                                &lt;controlsPrimitives:CalendarDayButton <br />                                    Loaded="CalendarDayButton_Loaded" <br />                                    Background="{TemplateBinding Background}" <br />                                    BorderBrush="{TemplateBinding BorderBrush}"<br />                                        <br />                                    Content="{TemplateBinding Content}"<br />                                    BorderThickness="{TemplateBinding BorderThickness}" <br />                                        <br />                                    x:Name="CalendarDayButton" Click="CalendarDayButton_Click"/&gt;<br />                            &lt;/StackPanel&gt;        <br />                        &lt;/Border&gt;<br />                    &lt;/ControlTemplate&gt;<br />                &lt;/Setter.Value&gt;<br />            &lt;/Setter&gt;<br />        <br />&lt;/style&gt;<br />&lt;/grid.resources&gt;<br />&lt;controls:calendar background="White" calendardaybuttonstyle="{StaticResource CalendarDayButtonStyle}" x:name="InnerCalendar"&gt;<br />&lt;/controls:calendar&gt;<br /></pre><br />So what is going on here is:<br />We are changing the ControlTemplate of CalendayDayButton for a new one which consits of a Border and a StackPanel containing a new CalendarDayButton. This is important, because now we now that each "day" in the Calendar will be represented by this StackPanel to which we can add additional components.<br />As promised we override the Loaded event. Let's see the code-behind:<br /><br /><pre class="prettyprint"><br />private void CalendarDayButton_Loaded(object sender, RoutedEventArgs e)<br />{<br /> var button = sender as CalendarDayButton;<br /> calendarButtons.Add(button);<br /><br /> //Resizing the buttons is the only way to change the dimensions of the calendar<br /> button.Width = this.ActualWidth / 9;<br /> button.Height = this.ActualHeight / 8;<br /><br /> if (calendarButtons.Count == 42)<br /> {<br />  FillCalendar();<br /> }<br />}<br /></pre><p>We are simple take the button, store it in our inner collection (called calendarButtons) for further manipulations and then we perform some Resizing. The only way to force Calendar to Resize itself to the values which you specify in "Width" and "Height" properties is actually to change the dimensions of the inner buttons.</p>And last we check if all button had been loaded and if yes then we call "FillCallendar" method - yes this will be the method which will fill in the events to the calendar.<br /><br />Before we go there we need to define the Dependency Properties which will allow us to bind the desired values (collection of items, DateTime property name event style and SelectedEvent property).<br /><br /><pre class="prettyprint"><br /><br />public static readonly DependencyProperty SelectedEventProperty = DependencyProperty.Register("SelectedEvent", typeof(Object), typeof(EventCalendar), null);<br />public Object SelectedEvent<br />{<br /> get { return (Object)GetValue(SelectedEventProperty); }<br /> set { SetValue(SelectedEventProperty, value); }<br />}<br /><br />public static readonly DependencyProperty CalendarEventButtonStyleProperty = DependencyProperty.Register("CalendarEventButtonStyle", typeof(Style), typeof(EventCalendar), null);<br />public Style CalendarEventButtonStyle<br />{<br /> get { return (Style)GetValue(CalendarEventButtonStyleProperty); }<br /> set { SetValue(CalendarEventButtonStyleProperty, value); }<br />}<br /><br />public static readonly DependencyProperty DatePropertyNameProperty = DependencyProperty.Register("DatePropertyName", typeof(String), typeof(EventCalendar), null);<br />public String DatePropertyName<br />{<br /> get { return (String)GetValue(DatePropertyNameProperty); }<br /> set { SetValue(DatePropertyNameProperty, value); }<br />}<br /><br />public static readonly DependencyProperty ItemsSourceProperty = DependencyProperty.Register("ItemsSource", typeof(IEnumerable), typeof(EventCalendar),<br /> new PropertyMetadata(ItemsSourcePropertyChanged));<br /><br />public IEnumerable ItemsSource<br />{<br /> get { return (IEnumerable)GetValue(ItemsSourceProperty); }<br /> set { SetValue(ItemsSourceProperty, value); }<br />}<br /></pre><br />You can see that there is a handler attached to the change of ItemsSourceProperty. This handler is called whenever this property changes. This is a important part, we take the Items, determine which property contains the DateTime value and we will group these Items by this property and store it in internal dictionary of type Dictionary&lt;DateTime, &lt;List&lt;Object&gt;&gt;.<br /><pre class="prettyprint"><br />public static void ItemsSourcePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)<br />{<br />    var owner = d as EventCalendar;<br />    //if the property was set to null we have to clear all the events from calendar<br />    if (e.NewValue == null)<br />    {<br />        owner.ClearCallendar();<br />        return;<br />    }<br />    <br />    IEnumerable rawItems = (IEnumerable)e.NewValue;<br />    PropertyInfo property = null;<br /><br />    //to determine the if the Count>0<br />    var enumerator = rawItems.GetEnumerator();<br />    if(!enumerator.MoveNext()){<br />        owner.ClearCallendar();<br />        return;<br />    }<br /><br />    Object o = enumerator.Current;<br />    Type type = o.GetType();<br /><br />    //get the type of the properties inside of the IEnumerable<br />    property = type.GetProperty(owner.DatePropertyName);<br />    <br />    if (property != null)<br />    {<br />        IEnumerable&lt;Object&gt; items = Enumerable.Cast&lt;Object&gt;((IEnumerable)e.NewValue);<br />        //group the items and store in a dictionary<br />        if (items != null)<br />        {<br />            var parDate = items<br />                        .GroupBy(x =&gt; GetDateValue(x, property))<br />                        .ToDictionary(x =&gt; x.Key, x =&gt; x.ToList());<br />            owner.ItemsSourceDictionary = parDate;<br />            owner.FillCalendar();<br />        }<br />    }<br />}<br /><br />//Returns the DateTime value of a property specified by its information<br />public static DateTime GetDateValue (Object x, PropertyInfo property)<br />{<br />    return ((DateTime)property.GetValue(x,null)).Date;<br />}<br /></pre><p>It is a bit complicated - and that comes probably from my poor knowledge and experience of working with raw IEnumerable. Basically I need to get the type of the items inside of the IEnumerable and then using this Type I can obtain the value of the DateTime property and group the values and store in an inner dictionary.</p><br />You can see that there is a simple helper functions which just takes PropertyInfo and Object and returns the Date value of that property. I prefer to get when using "Data" property I am sure that I will have exact "day" without hours and minutes and than I can group this data by this "day".<br /><br />Now that we have the grouped events, we have to place them in the calendar. To create this function I have used to example shown on <a href="http://blogs.msdn.com/b/aurelien/archive/2008/11/03/comment-ajouter-du-contenu-un-calendar-silverlight.aspx">this blog</a>.<br /><br /><pre class="prettyprint"><br />private void FillCalendar(DateTime firstDate)<br />{<br />    if (ItemsSourceDictionary!=null && ItemsSourceDictionary.Count >0)<br />    {                <br />        DateTime currentDay;<br /><br />        int weekDay = (int)firstDate.DayOfWeek;<br />        if (weekDay == 0) weekDay = 7;<br />        if (weekDay == 1) weekDay = 8;<br /><br />        for (int counter = 0; counter < calendarButtons.Count;counter++)<br />        {<br />            var button = calendarButtons[counter];<br />            var panel = button.Parent as StackPanel;<br /><br /><br />            int nbControls = panel.Children.Count;<br />            for (int i = nbControls - 1; i > 0; i--)<br />            {<br />                panel.Children.RemoveAt(i);<br />            }<br /><br />            currentDay = firstDate.AddDays(counter).AddDays(-weekDay);<br /><br />            if (ItemsSourceDictionary.ContainsKey(currentDay))<br />            {<br />                var events = ItemsSourceDictionary[currentDay];<br />                foreach (Object calendarEvent in events)<br />                {<br />                    Button btn = new Button();<br />                    btn.DataContext = calendarEvent;<br />                    btn.Style = CalendarEventButtonStyle;<br />                    panel.Children.Add(btn);<br />                    btn.Click += new RoutedEventHandler(EventButton_Click);<br />                }<br />            }<br />        }<br />    }<br />}<br /></pre><br />This function accepts a DateTime parameter which is the first date of the month which is being shown in the Calendar. When the first of the month is Monday, than it will be shown as a first in the second row. When it is Tuesday, it will be shown as the second in the second row. For other cases, it will be shown in the first row.<br />Thus we can easily subtract the integer values specifying which the day in the week (eg. 3 for Thursday) and we will obtain the date which is shown in the first cell.<br /><br />The day which is being shown in the calendar is exposed by <b>Calendar.DisplayDate</b> Property and we can easily access that to obtain the month which is being shown (and thus the first day of the month).<br /><br />So we just iterate over all the buttons, determine the date for each and knowing that the buttons are wrapped by a StackPanel we can add to this panel the events.<br />Each event is represented by a Button and the style which is exposed as DependencyProperty is applied.<br /><br /><h3>Exposed events</h3>This component exposes two events, one for the moment when the user clicks on existing "Event" in the calendar and second one for the click on the button of the day.<br /><pre class="prettyprint"><br />public event EventHandler&lt;calendareventargs&gt; EventClick;<br />public event EventHandler<calendareventargs> DayClick;<br /></pre>When the user clicks on existing event in the calendar, we pass the clicked "Event" wrapped by "CalendarEventArgs" class.<br /><pre class="prettyprint"><br />void EventButton_Click(object sender, RoutedEventArgs e)<br />{<br />    object eventClicked = (sender as Button).DataContext as object;<br />    <br />    //set the selected event<br />    SelectedEvent = eventClicked;<br /><br />    //just pass the click event to the hosting envirenment of the component<br />    if (EventClick != null)<br />    {<br />        EventClick(sender, new CalendarEventArgs(eventClicked));<br />    }<br />}<br /></pre>When the user clicks on the button of the day, we passed the Date of this day wrapped up by CalendarEventArgs.<br /><pre class="prettyprint"><br />private void CalendarDayButton_Click(object sender, RoutedEventArgs e)<br />{<br />    CalendarDayButton button = sender as CalendarDayButton;<br />    DateTime date = GetDate(GetFirstCalendarDate(),button);<br /><br />    if(date!=DateTime.MinValue && DayClick!=null)<br />    {<br />        DayClick(sender,new CalendarEventArgs(date));<br />    }<br />}<br /></pre>We can obtain the Date for the button by method similar to the one described above.<br /><h3>Summary</h3>There is no more to that, as I said the component stays super simple, just one class, you can style the Events which are placed to the Calendar and you have to handle the other actions (like eg. adding an "Event" when clicking on the "day" button) by yourself.<br /><a href="https://github.com/hoonzis/SilverlightEventCalendar"><b><br />Download the source from GitHub</b><br /></a>