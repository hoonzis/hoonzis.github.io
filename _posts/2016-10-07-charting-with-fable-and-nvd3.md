---
layout: post
title: Charting with Fable and NVD3
date: '2016-11-02T05:25:00.000-08:00'
author: Jan Fajfr
tags:
- Fable, F#
modified_time: '2016-11-02T05:11:43.965-08:00'
---
If you are F# developer, chances are you have probably already heard of [Fable](http://fable.io/). Fable transpiles F# code into JavaScript, so you can run your F# in the browser. It will also generate map files, so that you can even debug F# in the browser and the generated JS is actually very readable so if something goes wrong you can still look to the "compiled" code. To sum it up, it's really a great project and I was amazed on how few modifications were necessary to my code to make it compile into JS. I am working on a small application to visualize some financial data and I figured out it would be great to use Fable for this. So I set myself to make Fable work with [NVD3](https://github.com/novus/nvd3) and draw some interesting charts with F#.

The web that I am creating is a small tool to visualize option prices and payoff charts. It is available here: http://www.payoffcharts.com and it uses Fable. The code presented here is all available inside my [Pricer](https://github.com/hoonzis/Pricer) repository, just check it out and brows for the charting code:

The aim of this tutorial will be just to generate some random data and show it in a scatter chart:
![scatterExample](https://raw.githubusercontent.com/hoonzis/hoonzis.github.io/master/images/optionscharts/scatterExample.PNG) or you can see it life here: http://www.payoffcharts.com/chartingTest.html.

### Installing Fable
Fable is a compiler, so you might expect an executable. In this case it comes bundled as **npm** package, which you might want to install globally:

```
npm install -g fable-compiler
```

### Setup the Fable project
Before you get started with any code, you have to consider few things:

* ##### Single fsx or a project?
Are you going to fit everything into single F# file or you will create a project? Fable allows you to do both and in the simplest situation I can just point fable to a single fsx file, but if you plan to build something bigger, you better create F# project (F# library will work, even though you won't distribute anything as library but compile into JS instead).

* ##### JavaScript modules
How the resulting JavaScript should be structured and packaged? Two most common ways of defining modules in JavaScript are AMD and CommonJS.

* ##### JavaScript bundling
Fable will create one JavaScript file per F# file, these files have to be then loaded by the browser. Depending on the module pattern (CommonJS vs AMD) you will have to bundle them together to a single JavaScript file which will be included in the html.

I have chosen the following setup: F# project with multiple files. CommonJS as module system, bundled with Webpack. To go for this configuration, you will have to create the following 3 files in the root of the project folder:

**package.json**  - will define your JavaScript project (standard Node project), here you can list the necessary packages that you depend on.

```json
{
  "private": false,
  "name": "fabled-pricer",
  "version": "1.0.0",
  "main": "index.js",
  "author": "Jan Fajfr",
  "license": "MIT",
  "dependencies": {
    "core-js": "^2.4.0",
    "d3": "^3.5.17",
    "fable-core": "0.6.6",
    "nvd3": "^1.8.4",
  },
  "engines": {
    "fable": ">=0.2.11"
  },
  "devDependencies": {
    "source-map-loader": "^0.1.5",
    "webpack": "^1.13.2"
  }
}
```

**fableconfig.json** - Fable's configuration - tell fable what are his dependencies, which JavaScript module system should be used. Since I have decided to use webpack for JS files bundling, I can also ask fable to run webpack when the compilation is finished.

```json
{
  "module":  "commonjs",
  "sourceMaps": true,
  "projFile": "Pricer.Fabled.fsproj",
  "outDir": "CompiledJs/Pricer.Fabled",
  "scripts": {
    "postbuild": "webpack"
  },
  "targets": {
    "watch": {
      "scripts": {
        "postbuild": "webpack --watch"
      }
    }
  }
}
```

**webpack.config.json** - Webpack's config, tell him where the JS files are (generated by fable in the previous step) and where to output the bundled result.

```javascript
module.exports = {
    entry: {
        chartingTest: "./CompiledJs/Pricer.Fabled/ChartingTest"
    },
    output: {
        filename: "[name].bundle.js",
        path: "./out"
    },
    devtool: "source-map",
    module: {
        preLoaders: [{
            loader: "source-map-loader",
            exclude: /node_modules/,
        }],
    },
    externals: {
        "d3": "d3"
    }
};
```

### Creating the web page
The page itself will be very small - it contains only one div tag which we will use to draw the chart. We also have to reference all JavaScript libraries on which we are depending and finally the JavaScript compiled from our F# code.

```html
<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>Chart test</title>
    <script src="node_modules/d3/d3.min.js" charset="utf-8"></script>
    <script src="node_modules/nvd3/build/nv.d3.js"></script>
    <link href="node_modules/nvd3/build/nv.d3.css" rel="stylesheet">
    <script src="node_modules/core-js/client/core.min.js"></script>
</head>
<body>
    <div>
        <svg id="chart"></svg>
    </div>
    <script src="out/chartingTest.bundle.js"></script>
</body>
</html>
```

### The F# application
Let's look at the content of "main" file. The file contains a single module, with a single function that is invoked. This function will be called when the JavaScript is loaded.

```ocaml
namespace Pricer.Fabled

open System

module ChartingTest =

    let random = new Random()

    let randomValues() =
        [|1 .. 10|] |> Array.map (fun i ->
        {
            x = new DateTime(2014, i, 1)
            y = float (random.Next() / 100000)
            size = float (random.Next())
        })

    let drawChart() =
        let series = [|
                {
                    key = "Series 1"
                    values = randomValues()
                };
                {
                    key = "Series 2"
                    values = randomValues()
                }
            |]

        Charting.drawScatter series "#chart"

    drawChart()
```

All we are doing here is preparing the data for the charting. We will generate an array of items for the scatter chart. Each item has three properties (x,y,size). Then we will wrap all the data into two series and pass to the drawing function. Note that nothing is said here about the types of the values, but the standard NVD3 JavaScript code would look very similar. You can look at the [official scatter chart example](https://github.com/nvd3-community/nvd3/blob/gh-pages/examples/scatterChart.html). We will look into the details of **drawScatter** method later.

### Defining NVD3 types
In the previous snippet we have created an array of "Series" with two Series of random data. The shape of the series reflects what NVD3 is expecting, but since we are compiling from F# we have to define the types that would resemble to what NVD3 is expecting. That is really not that hard, these 2 records will do:

```ocaml
type DateScatterValue = {
    x: DateTime
    y: float
    size: float
}

type Series<'a> = {
    key: string
    values: 'a array
}
```

These are not all the types that we will need, but the rest will be much clearer if we look at the function that draws the data.

### Drawing the charts
Our drawing function takes two parameters. First the data to draw and a selector which will tell us to which element in the HTML page we should draw the chart. The content will again resemble a lot a JavaScript NVD3 [official scatter chart example](https://github.com/nvd3-community/nvd3/blob/gh-pages/examples/scatterChart.html).

```ocaml
let drawScatter (data: Series<DateScatterValue> array) (chartSelector:string) xLabel yLabel =
    let colors = D3.Scale.Globals.category10()
    let chart = nv.models.scatterChart().pointRange([|10.0;800.0|]).showLegend(true).showXAxis(true).color(colors.range())
    chart.yAxis.axisLabel("Strike") |> ignore
    chart.xAxis.axisLabel("Expiry") |> ignore
    let chartElement = D3.Globals.select(selector);
    chartElement.html("") |> ignore
    chartElement.style("height","500px") |> ignore
    chartElement.datum(data).call(chart) |> ignore
```

This function calls two libraries: NVD3 and D3 itself. There is however a small difference. For any NVD3 code that we call, we have to define the F# types, so that F# compiler is not confused, and Fable "knows" that it can just output the code itself.

For D3 however we can use the [Fable D3 Bindings](https://www.npmjs.com/package/fable-import-d3) which are available as npm package. That basically means that for instance **D3.Scale.Globals.category10** has been defined in the D3 bindings DLL and Fable knows that the correct JavaScript output is **d3.scale.category10()**, without us telling him.

### Creating custom bindigs for NVD3
For NVD3, we have to defined the bindings manually. So let's start with the call to **nv.models.scatterChart**

```ocaml
module nv =
    let models: ChartModels = failwith "JS only"

type ChartModels =
    abstract lineChart: unit -> LineChart
    abstract scatterChart: unit -> ScatterChart
```

So we have defined **nv** model with **models** field, this will make F# compiler happy. And fable will just output the same code in JavaScript. ChartModels is a type that provides all the charts. Our example is using only **scatterChart** but I have defined also **lineChart** just to let you know the whole idea behind this:

```ocaml
[<AbstractClass>]
type Chart() =
    abstract xAxis: Axis
    abstract yAxis: Axis
    abstract showLegend: bool -> Chart
    abstract showXAxis: bool -> Chart
    abstract showYAxis: bool -> Chart
    abstract color: string[] -> Chart

[<AbstractClass>]
type LineChart() = inherit Chart()
        with member __.useInteractiveGuideline (value:bool): Chart = failwith "JSOnly"

[<AbstractClass>]
type ScatterChart() = inherit Chart()
    with member __.pointRange(value: double array): ScatterChart = failwith "JSOnly"
```

**ScatterChart** and **LineChart** both inherit from the base **Chart** type. We also have to define the Axis:

```ocaml
type Axis =
    abstract axisLabel: string -> Axis
    abstract tickFormat: System.Func<Object,string> -> Axis
```

Writing these bindings for any library becomes very easy once you understand that your are just defining interfaces and abstract classes - no implementation. You just have to make F# compiler happy and be sure that the underlying JavaScript calls will be available.

Now that's everything there is to it. Just to complete this post I wanted to added two more subjects that I have run into, so continue the read if you wish:
- Issues with custom bindings
- Emitting custom JavaScript

### Custom bindings possible issues - objects as functions
In JavaScript objects are functions and thus can be invoked. Not in F# though and so it can be quite complicated for anyone writing the bindings for existing JavaScript library. For example, I wanted to use D3 Time formatting capabilities to shape the **Axis** ticks into something readable. In JavaScript you would do something like this (very straightforward):

```javascript
chart.xAxis.tickFormat(d3.time.format("%x"));
```

NVD3 has **tickFormat** method available on all Axis, which in JavaScript takes a function transforming anything into string representation of what is shown on the axis. The signature in F# would be something like: **tickFormat(Object -> string)**. Fable comes with D3 bindings, that make the D3 Time Format available on global time module (D3.Time.Globals.format()), so one would expect something like this to work:

```ocaml
chart.xAxis.tickFormat(D3.Time.Globals.format("%x"))
```

That's not really how things works since what you get is a **D3.Time.Format** object not compatible with the **Object->string** function signature. In JavaScript objects are functions, so sometimes (and it is the case of **d3.time.format("%")** you get an object that can be invoked directly as function. D3 uses this pattern a lot. Scales for instance as well are objects an functions in the same time as well.

In F# world, one just can't invoke objects as if they would be functions, so it has to be modelled differently. The **D3.Time.Globals.fomrat("%x")** returns **D3.Time.Format** object which has **Invoke** method that takes DateTime. So you might try something like this:

```ocaml
chart.xAxis.tickFormat(fun x -> D3.Time.Globals.format("%x").Invoke(x))
 ```

Well still no luck since **Invoke** method expects DateTime and you are passing in an Object, because the signature of tickFormat is Object -> string. So you will have to cast to DateTime just to make the F# compiler happy, even though you know that the underlying JavaScript would work.

### Emitting custom JavaScript
Fable allows you to interact with JavaScript with few different ways. One way is to define function calls that will emit specific JavaScript code. Here is the official example:

```ocaml
open Fable.Core

[<Emit("$0 + $1")>]
let add (x: int) (y: string): float = jsNative

let result = add 1 "2"
```

This can be very useful sometimes. I have ended up in a situation when I needed create Date objects from the number of ticks. This is quite standard and both, the JavaScript **Date** object as well as .NET **DateTime** have a constructor which takes number of ticks as integer parameter.

So you might want to try the DateTime(int numberOfTicks) constructor which should create a DateTime instance from number of ticks - but this one is not supported by Fable. In fact Fable will try to invoke a different constructor DateTime(int years, int months, int days) and won't the last two parameters.

Here there is no way around than use custom function that will emit the correct JavaScript to construct a new Date which one can than pass safely to the D3 Time Format.

```ocaml
[<Emit("new Date($0)")>]
let fromTicks (ticks: int): DateTime = jsNative

let myDate = DateUtils.fromTicks(1238985)
```

The resulting JavaScript will just look like this:

```JavaScript
var myDate = new Date(1238985);
```

Now of course the other way around is to do a PR on Fable and fix this issue which after all should not be that hard and I guess thats what I should do instead of continuing this already quite long post.
