---
layout: post
title: ASP.NET Forms Authentication and Java client
date: '2011-07-08T02:36:00.000-07:00'
author: Jan Fajfr
tags:
- Security
- Java
- WCF
modified_time: '2014-06-26T14:59:05.450-07:00'
thumbnail: http://4.bp.blogspot.com/-Yli21ev2fgI/TgdPxAh6YFI/AAAAAAAAAMI/4Na-cg7zLIU/s72-c/fidler_cookie.PNG
blogger_id: tag:blogger.com,1999:blog-1710034134179566048.post-5837908066316981280
blogger_orig_url: http://hoonzis.blogspot.com/2011/07/aspnet-forms-authentication-and-java.html
---

This post describes my later situation. I have a Silverlight application which talks to traditional WCF services in backend. The services have so far been configured automatically - so let's say Visual Studio took care of the web.config. Newest requirement to my application was to allow Java clients consume these services.<br /><br />The prerequisites for this post are some basic knowledge of WCF (bindings, services, endpoints) and some knowledge of Java (I am using Axis to generate the clients...for the first time).<br /><br />To make it a bit more complicated: I was using FormsAuthentication on the backend side, since these services are hosted by IIS 7.<br /><br />Here I want to show what to do use Forms Authentication from Java application, mobile client or any other non-browser client.<br /><br />The second part which describes how to enable WCF services to be consumed by JAVA client is described in <a href="{{ site.baseurl }}{% post_url 2011-07-08-consuming-wcf-services-with-java-client %}">my other post.</a><br /><h3>IIS 7 buid-in Authentication Service</h3>I was using the build-in authentication service in order to authenticate the client, which is just a basic service, which offers methods such as Login, Logout etc.<br />This service can be enabled on IIS server using the following configuration:<br /><pre class="prettyprint"><br />&ltsystem.web.extensions&gt<br />  &ltscripting&gt<br />    &ltwebServices&gt<br />      &ltauthenticationService enabled="true" requireSSL="false"/&gt<br />    &lt/webServices&gt<br />  &lt/scripting&gt<br />&lt/system.web.extensions&gt<br /></pre>And we also need to expose this service:<br /><pre class="prettyprint"><br />&ltservice behaviorConfiguration="NeutralBehavior" name="System.Web.ApplicationServices.AuthenticationService"&gt<br />    &ltendpoint address="" binding="basicHttpBinding" contract="System.Web.ApplicationServices.AuthenticationService" /&gt<br />    &ltendpoint address="mex" binding="mexHttpBinding" contract="IMetadataExchange" /&gt<br />&lt/service&gt<br /></pre>Now that service works great from Silverlight client but I was not able to generate Java client for this service - I tried with different versions of Axis and settings - but it did not work for me.<br /><br />So for the non-Silverlight client I needed to write my own Authentication service. That is actually prety easy using the <b>FormsAuthentication</b> static class.<br /><pre class="prettyprint"><br />[OperationContract]<br />public Login(String login, String password)<br />{<br />    //your way to auth the user againts DB or whatever<br />    var user = UserService.AuthenticateUser(login, password);<br />    <br />    if (user != null)<br />    {<br />        FormsAuthentication.SetAuthCookie(login, true);<br />    }<br />    return null;<br />}<br /></pre>After you check if the user is connected, you can just call the <b>SetAuthCookie</b> method. This method adds authentication token to the response which will go to server. Then the browser adds this token to any request which he will send to the server.<br />And here comes the problem: how to use this with non-browser based application?<br />Let me continue.<br /><br /><h3>Services secured using PrincipalPermission</h3>I use FormsAuthentication, because it allows me to secure all service just by adding the <b>PrincipalPermission</b> attribute over each Service method. So my WCFUserService can look like this:<br /><pre class="prettyprint"><br />public class WCFTagService<br />{<br />  public WCFTagService()<br />  {<br />      Thread.CurrentPrincipal = HttpContext.Current.User;<br />  }<br />  <br />  [OperationContract]<br />  [PrincipalPermission(SecurityAction.Demand, Authenticated = true)]<br />  public Object GetSecuredData(int param)<br />  {<br />      return MyDB.GetData();<br />  }<br />}<br /></pre>In the constructor the <b>CurrentPrincipal</b> is set to the current user of the ASP.NET application (again we are hosting this service in IIS), than the [PrincipalPermission] attribute will be check even before the method is executed if the user is logged in.<br />And how is the <b>HttpContext.Current.User determined</b>?<br />Well simply by checking the authentication token which the browser adds to the request. IIS will automatically check this token and populated the <b>User</b> static class with the correct identity.<br /><br /><h3>Adding one more authentication service for Java Clients</h3>This is definitely not correct but it is the only way I was able to get it to work. Basically when I call<br /><pre class="prettyprint"><br />FormsAuthentication.SetAuthCookie(login, true);<br /></pre>the cookie is added to the response and I will have to get it on the client (Java) side. Actually I was not able to achieve that - I will describe the approach I took lower, but I just did not get the cookie from the response. So I decided to build one more service which will just return the authentication token (or cookie if you will).<br /><pre class="brush:csharp">[OperationContract]<br />public String LoginCookie(String login, String password)<br />{<br />  var user = UserService.AuthenticateUser(login, password);<br />  if (user != null)<br />  {<br />      var cookie = FormsAuthentication.GetAuthCookie(login, true);<br />      return cookie.Value;<br />  }<br />  return null;<br />}<br /></pre>Ok that's it, we are done. We can almost switch to JAVA.<br /><br /><h3>Accessing Authentication Service using the Axis generated client</h3>Before we start, we need to generated the client, either you can use the build in tool in Eclipse ("New -> Other -> Web Service Client") or you can use the commander line "WSDLtoJava" utility. In both cases you have to enter just the URL of the WSDL.<br />When the client is ready, you can see that there is quite a lot of code(10kLines) generated for you.<br /><pre class="prettyprint"><br />MyServiceLocator locator = new MyServiceLocator();<br />AuthService client = locator.getBasicHttpBinding_AuthService();<br />String cookie = client.LoginCookie("login","password");<br /></pre>That is quite simple, I am calling the method which I have defined before which gives me the authentication cookie. Remember that this "Authentication Service" stays open, so anybody can call the methods. Now when we have the cookie, we can use it to make calls to other already protected services.<br /><pre class="prettyprint"><br />MyServiceLocator locator = new MyServiceLocator();<br />WCFUserService client = locator.getBasicHttpBinding_WCFUserService();<br />((Stub)client)._setProperty(Call.SESSION_MAINTAIN_PROPERTY,new Boolean(true));<br />((Stub)client)._setProperty(HTTPConstants.HEADER_COOKIE, ".ASPXAUTH=" + <br />cookie);<br />Object data = client.GetSecuredData(myParam);<br /></pre>The generated client does not allow you to add cookies, but you can convert the client to <b>org.appache.axis.client.Stub</b> which allows you to call <b>_setProperty</b> method a static HttpConstatns class provides the names of the headers which you can set.<br /><b>Now notice the "ASPXAUTH=" that is the prefix(or in other words the name) of the cookie and it has to be there</b>. It took me a while to find out in what exact form should I send the cookie, finally <a href="http://www.fiddler2.com/fiddler2/">Fiddler</a> came as help -  I used the Silverlight client to see what exactly he is sending and I just did the same.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-Yli21ev2fgI/TgdPxAh6YFI/AAAAAAAAAMI/4Na-cg7zLIU/s1600/fidler_cookie.PNG" imageanchor="1" style="margin-left:1em; margin-right:1em"><img border="0" height="114" width="320" src="http://4.bp.blogspot.com/-Yli21ev2fgI/TgdPxAh6YFI/AAAAAAAAAMI/4Na-cg7zLIU/s320/fidler_cookie.PNG" /></a></div>What is little bit said is the fact, that we have to create a special method to be called by the Java client which returns the authentication token directly and no as a cookie.<br />I was thinking - it could not be that hard, generate a client and get the cookie. This way I could have only one authentication method used by browser-based clients and Java clients. But I just did not managed to do that.<br /><br />I will show an attempt which I did  - but did not succeed.<br /><br /><h3>Creating the client dynamically</h3>The <b>java.rmi</b> namespace provides classes which will the creation of web service client on the fly (without generation). This has some advantages, specially that you can create a <b>javax.rmi.xml.Service</b> class which allows assignment of special handlers, which are executed during the "reception" and "sending" of SOAP messages, these handlers can allow you to alter the content of the message and thus provide possibility to do some additional tuning.<br /><br />Personally I thought, that I will be able to create my own handler <b>to recuperate the authentication cookie</b> send the standard way. But I did not manage to get the cookie from the SOAP message. Well that is actually normal, because the Cookie is not part of the SOAP message but instead part of the HTTP message (which wraps the SOAP message). But that is the problem I was not able to locate the cookie in the HTTP Response message, anyone knows how to do that?<br /><br />I will provide here a conception of my solution - maybe someone will be able to finalize and obtain the cookie from the response of the authentication service.<br /><pre class="prettyprint"><br />try {<br />  QName serviceName = new QName("http://mynamespace","AuthService");<br />  URL wsdlLocation = new URL("http://localhost:49830/WCFServices/WCFUserService.svc?wsdl");<br />  // Service<br />  ServiceFactory factory = ServiceFactory.newInstance();<br />  Service service =  factory.createService(wsdlLocation,serviceName);<br />  <br />  //Add the handler to the handler chain<br />  HandlerRegistry hr = service.getHandlerRegistry();<br />  HandlerInfo hi = new HandlerInfo();<br />  hi.setHandlerClass(SimpleHandler.class);<br />  handlerChain.add(hi);<br />  <br />  QName  portName = new QName("http://localhost:49830/WCFServices/WCFUserService.svc?wsdl", "BasicHttpBinding_AuthService");<br />  List handlerChain = hr.getHandlerChain(portName);<br />  <br />  QName operationName = new QName("http://localhost:49830/WCFServices/WCFUserService.svc?wsdl", "Login");<br />  Call call = service.createCall(portName,operationName);<br />  <br />  //call the operation<br />  Object resp = call.invoke(new java.lang.Object[] {"login","pass"});<br />}<br /></pre>To be able to call the web service dynamically, you will need to specify the names of the service, the port and the operations, you can find these easily in the WSDL definition.<br />Here follows the definition of the SimpleHandler which is added to the handler chain<br /><pre class="prettyprint"><br />public class SimpleHandler extends GenericHandler {<br /> <br />  HandlerInfo hi;<br /> <br />  public void init(HandlerInfo info) {<br />    hi = info;<br />  }<br /><br />  public QName[] getHeaders() {<br />    return hi.getHeaders();<br />  }<br /><br />  public boolean handleResponse(MessageContext context) {<br />    try {<br />     <br />     //Iterate over all properties - did not find the cookie there :(<br />     Iterator properties = context.getPropertyNames();<br />        while(properties.hasNext()){<br />         Object property = properties.next();<br />         System.out.println(property.toString());<br />        }<br />        <br />      //examine the response header - did not find the cookie there either :( <br />      if(context.containsProperty("response")){<br />       Object response = context.getProperty("response");<br />       HttpResponse httpResponse = (HttpResponse)response;<br />       <br />       Header[] headers = httpResponse.getAllHeaders();<br />       for(Header header:headers){<br />        System.out.println(header.toString());<br />       }<br />      }<br />     <br />     //here is how to get the SOAP headers - they do not serve - we need pure HTTP response<br />      // get the soap header<br />      SOAPMessageContext smc = (SOAPMessageContext) context;<br />      SOAPMessage message = smc.getMessage();<br />      <br />    } catch (Exception e) {<br />      throw new JAXRPCException(e);<br />    }<br />    return true;<br />  }<br />  public boolean handleRequest(MessageContext context) { <br />    return true;<br />  }<br />}<br /></pre><br /><br /><h3>Alternative approach using WCF Inspectors</h3>When looking into this problem, I found one alternative approach that you can use when dealing with Security and WCF Service.<br />The solution is basic:<br /><ul><li>Give up on FormsAuthentication</li><li>Define your own authentication tickets or just pass the login/pass combination on each request in the HTTP Header</li><li>Define a Message InInspector on the Server which would read the message upon its reception and check the availability of the authentication token or the credentials  in the message header</li></ul>When following this approach what might come handy is an easy way to generate and later control the Authentication ticket. FormsAuthentication can actually help you with this. Here is what happens when you call the <b>FormsAuthentication.GetAuthCookie</b>.<br /><pre class="prettyprint"><br />FormsAuthenticationTicket ticket = new FormsAuthenticationTicket(1, login, DateTime.Now, DateTime.Now.AddMinutes(30), false, login);<br />string encryptedTicket = FormsAuthentication.Encrypt(ticket);<br />HttpCookie cookie = new HttpCookie(FormsAuthentication.FormsCookieName, encryptedTicket);<br /></pre>So you can create an Inspector class, which will do the reverse of this process:<br /><pre class="prettyprint">public class TestInspector : IDispatchMessageInspector<br />{<br />    public TestInspector()  { }<br />    <br />    public object AfterReceiveRequest(ref System.ServiceModel.Channels.Message request, System.ServiceModel.IClientChannel channel, System.ServiceModel.InstanceContext instanceContext)<br />    {<br />        var httpRequest = (HttpRequestMessageProperty)request.Properties[HttpRequestMessageProperty.Name];<br />        var cookie = httpRequest.Headers[HttpRequestHeader.Authorization];<br />        if(cookie == null)<br />        {<br />          throw new SecurityException("Not authenticated!");<br />        }<br />        var ticket = FormsAuthentication.Decrypt(cookie);<br />        if(ticket.IsExpired)<br />        {<br />          throw new SecurityException("Ticket expired");<br />        }<br />    }<br /><br />    public void BeforeSendReply(ref System.ServiceModel.Channels.Message reply, object correlationState)<br />    {<br />        <br />    }<br />}<br /></pre><h3>Securing the servicing using SSL</h3>When we pass the authentication token over the wire, we want to be sure, that no-one can intercept this token and act in name of the user against the services. To prevent this situation we can use SSL to secure the whole communication between client and server.<br /><br />The WCF configuration which is needed is quite simple, we just have to alter the standard <b>basicHttpBinding</b> by adding the <b>security</b> mode.<br /><pre class="prettyprint"><br />&ltbasicHttpBinding&gt<br />  &ltbinding name="SecurityByTransport"&gt<br />    &ltsecurity mode="Transport"&gt<br />      &lttransport clientCredentialType="None"/&gt<br />    &lt/security&gt<br />  &lt/binding&gt<br />&lt/basicHttpBinding&gt<br /></pre><br />Than comes the infrastructure work:<br /><br /><ul><li>Be sure to publish the service on your local IIS server (you cannot use the build-in Visual Studio Server</li><li>On the IIS server create a new certificate - for test purposes auto-signed</li><li>Configure a new binding to application that you have deployed using the certificate, that you have created</li></ul>This should be enough. Now we need to go back to the Java client - if we can regenerated the client using Axis. When you run the client for the first time, you will get the following exception:<br /><i>java client unable to find valid certification path to requested target</i><br />That is because JVM maintains its list of trusted server. If he sees that the certificate is signed by Certification Authority, he will add it to its "keystore". Because for testing you usually use Self-Signed certificate, JVM will not add it do the keystore, it has to be done manually.<br /><br />So: go back to the IIS 7 configuration and in the list of the certificates, select the certificate and on the "Details" tab page choose: "Copy to File".<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-ouZAfq6dmq4/TgiUWA_eqdI/AAAAAAAAAMQ/Af-8ZEURtdY/s1600/Capture1.PNG" imageanchor="1" style="margin-left:1em; margin-right:1em"><img border="0" height="320" width="299" src="http://1.bp.blogspot.com/-ouZAfq6dmq4/TgiUWA_eqdI/AAAAAAAAAMQ/Af-8ZEURtdY/s320/Capture1.PNG" /></a></div>You can leave the predefined option and just save the ".CER" wherever you want to.<br /><br />Now to finish you have to run the following command in the JAVA-HOME\BIN directory:<br /><pre>keytool.exe -import -alias localhost -file C:\myCert.cer -keystore "c:\Program Files\Java\jre6\lib\security\cacerts"<br /></pre><ul><li><b>localhost</b> - stands for the web server which holds the certificate (your local IIS).</li><li><b>cacerts directory</b> - is the store of trusted certificates.</li><li>The password is "changeit".</li></ul><br /><h3>Summary</h3>I tried to connect to secured WCF services hosted on IIS server with Java client. During the process I found some issues, but at the end I was able to connect securely to the services. The main steps are:<br /><ul><li>Don't use IIS build-in Authentication Service</li><li>Provide a service which will return the Authnentication Cookie to the Java client</li><li>Pass this cookie along with any request which is sent to secured services</li></ul>In the end, I have showed how to enable SSL on the WCF service and how to consume the service with Java client.<br />And at last I presented an approach which should be taken to replace FormsAuthentication with your own authentication scheme using WCF Message Inspectors.