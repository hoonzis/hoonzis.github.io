---
layout: post
title: Choosing technologies for .NET project
date: '2012-02-04T10:44:00.000-08:00'
author: Jan Fajfr
tags:
- Security
- ".NET"
- Testing
- Architecture
modified_time: '2012-02-14T12:15:36.700-08:00'
blogger_id: tag:blogger.com,1999:blog-1710034134179566048.post-747965679601342524
blogger_orig_url: http://hoonzis.blogspot.com/2012/02/choosing-technologies-for-net-project.html
---

Our latest research and development project was an online banking application. While choosing the building pieces of this application, we tried to pick the State-Of-Art frameworks and technologies. This is not an easy task, while there are always several alternatives for each component. I have decided to created this post which sums up the technologies available for different parts of application and I will try regularly update it, to keep up with the changes.<br /><br />Here is the structure of this blog, according to which the technologies are grouped.<br /><br /><ul><li>DataAccess - ORM, data generation</li><li>Platform - Dependency Injection, Aspect Oriented Programming</li><li>Integration - SOAP/REST, messaging, distributed objects...</li><li>Testing - Unit testing and Mocking, Parametrized testing, Functional testing</li><li>Presentation layer</li><li>Security</li><li>Logging</li></ul><br /><br /><h3>Typical application</h3><br />Our application was a classical 3-tier application with database, business and presentation layers. <br />Data stored in SQL Server 2008. Data access layer implemented using Repository pattern and using ORM. Dependency Injection and Aspect Oriented Programming used to put together the application pieces. Services exposed using WCF, and two types of client applications: mobile and web. <br /><br />So the technologies presented here, are the ones mostly used in this scenarios, however as said before, I would like to update the post to give more information any time I cross another technology, and that might while working on different architectures.<br /><br /><h3>Data Access</h3>The most important part of the Data Access layer is the framework used for Object Relational Mapping (ORM). There are currently two major ORM frameworks in .NET:  <b>NHibernate</b> and <b>Entity Framework.</b> Both provide similar ORM functionalities (Code only approach, Lazy loading , use of POCOs as persistence classes).<br /><br /><b>Entity Framework</b> 4.0 has brought a lot of improvement to its previous version (named EF 1.0) which did not provide above mentioned functionalities and its comparable to <a href="http://nhforge.org/Default.aspx">NHibernate</a>. Crucial for ORM framework in .NET environment is the integration of LINQ (Language Integrated Query). <a href="http://msdn.microsoft.com/en-us/library/bb399572.aspx">Entity Framework</a> was the first to offer this functionality but the implementation in NHibernate followed shortly after.<br /><br /><b>NHibernate</b> has still several advantages among these it’s better ability to process batch treatment and also the fact that as an open source product it can be customized. On the other hand Entity Framework provides better tools integrated into Visual Studio.<br />One last thing which can justify the choice of NHibernate is the possibility of using FluentNHibernate.<br /><br /><b><a href="http://fluentnhibernate.org/">FluentNHibernate</a></b><br />NHibernate uses its XML based HBM format to define the mappings between entities and POCOs. While the separation of code and configuration in XML can be seen as nice approach it gets complicated once the XML configuration files are larger and once we are introducing changes into the POCOs. The XML is not checked upon the compilation, so potential errors can be detected at run-time only and are generally hard to localize.<br />NFluent allows us to define the mappings in strongly-typed C#, which practically eliminates these issues. If there is an error in configuration, it will be most likely discovered during the compilation. Currently Fluent allows provides almost full compatibility with HBM files, which means that what can be defined in HBM can be also defined in Fluent.<br /><br /><b>Data Generation</b><br /><b><a href="http://autopoco.codeplex.com/">AutoPoco</a></b> is a simple framework which allows generation of POCOs (Plain Old CLR Objects) with meaningful values. When building enterprise application we often need generate initial data for the database. This can of course be done using SQL scripts or in imperative language which we are using, but consists of lots of repetitive code and for loops in order to create sufficient amount of data. AutoPoco provides easy way to generate the starting data. It also provides several build-in sources for common properties which are stored in databases such as phone numbers, birth dates, name and credit card numbers.<br /><br /><h3>Platform</h3>There are two design patterns (or approaches) which are very often present among the several layers of enterprise applications: Dependency Injection and Aspect Oriented Programming.<br /><br />Dependency Injection is used to assemble complex system from existing blocks. There are several Dependency Injection containers available for .NET framework: <a href="http://www.springframework.net/">Spring.NET</a>, <a href="http://www.castleproject.org/container/">CastleWinsdor</a>, <a href="http://structuremap.net/structuremap/">StructureMap</a>, <a href="http://code.google.com/p/autofac/">AutoFac</a>, <a href="http://ninject.org/">Ninject</a>, <a href="http://unity.codeplex.com/">Unity</a> (by Microsoft), <a href="http://code.google.com/p/linfu/">LinFu</a>.<br /><br />Aspect Oriented Programming allows developers to separate cross-cutting concerns from the applications blocks. This is usually done by injecting code into object's existing methods.<br />There are several ways to implement AOP, two of these being most common: Proxy based AOP and IL Weaving based AOP.<br /><br />Proxy based AOP is easily achieved by wrapping targeted object by a proxy class. Than it is easy to intercept the calls to the target object by the proxy class and call the code, which should be injected. It just happens so, that the Dependency Injection containers use proxy classes and therefor most of them offer also AOP. (Spring.NET, CastleWinsdor).<br /><br />IL Weawing is an expression for injection of IL code after compile time before the generation of byte-code.<br /><br />There are two frameworks which provide AOP through IL Weaving: <a href="http://www.sharpcrafters.com/">PostSharp</a> and <a href="http://code.google.com/p/linfu/">LinFu</a>. PostSharp has a commercial licence, however at the time of writing this post(July 2011), there is also 45 days free trial. LinFu is an opensource project under LGPL licence which covers both IoC and AOP.<br /><br />I have used to choose Spring.NET because of it’s maturity, the fact that it is well documented, works great with NHibernate and allows both AOP as well as Dependency Injection. One of the disadvantages of Spring.NET is the XML configuration which as always can become too large to maintain. Other frameworks use C# as the language to configure the AOP or Dependency Injection (PostSharp makes use of attributes and frameworks such as Ninject or StructureMap use strongly typed classes to configure the dependency injection container).<br /><br />I have however decided to use Ninject on my last project, which seems to have a bit of momentum right now, and I will post here later pros/cons.<br /><br /><b>Code Verification (<a href="http://msdn.microsoft.com/en-us/devlabs/dd491992">Code Contracts</a>)</b><br />Design by contract is software design approach, which implies that developers define clear interfaces for each software component, specifying its exact behavior. The interfaces are defined by contracts and extend the possibilities of code verification and validation.<br />The term was first used by <a href="http://se.ethz.ch/~meyer/">Bertrand Meyer</a>, who made it part of his <a href="http://en.wikipedia.org/wiki/Eiffel_(programming_language)">Eiffel programming language</a>.<br /><br />Code Contracts is a language agnostic framework which enables the Design-by-Contract approach by allowing the programmer to define three types of conditions for each method:<br />Pre-condition - states in what forms the arguments of the method should be.<br />Post-condition - states what forms the outputs of the method will have.<br />Invariants - conditions which will always be true during the execution of the method.<br /><br />These conditions can be later verified by two types of checks:<br />Static checking - is being done at the compilation type. At this time the compiler does not know what will be the values passed as arguments to the methods, but from the execution tree can determine which method calls might potentially be evoked with non-compliant parameters.<br />Runtime checking - the code contracts are compiled as conditions directly into .NET byte-code. This allows the program to avoid writing conditions manually inside the method bodies.<br /><br />Note that Code Contracts are not language feature. They are composed of class library and the checking tools which are available as plugins for Visual Studio.<br /><br /><h3>Integration</h3>Distributed applications need a way of communication between the components. Remote Procedure Call(RPC) was the first technology used in distributed systems back in 70's. The choice here surely depends on the architecture of the application (client-server, publish-subscribe, ESB, and more...)<br /><br /><b>WCF</b><br />Flexible platform which provides abstraction of transport layer configuration (security, transport format, message patterns). <br />WCF options and choices:<br />Transportation protocol: WCF can user HTTP, TCP, MSMQ <br />Transportation format: XML, JSON, or Binnary<br /><br />One service can expose several Endpoints (URIs). Each Endpoint can be configured to use different Binding. Binding can have different transportation protocol and format options. The same services can be thus exposed using different protocols and formats. In our application we can use this advantage and expose different endpoints for different clients.<br /><br /><h3>Testing</h3>Several types of tests can be used to confirm the correct behavior of the application: Unit Tests, Integration tests, smoke tests, functional tests (or acceptance tests).<br /><br /><b>Unit Testing</b><br /><b>Mocking frameworks</b><br />When it comes to isolating the unit tests there are several Mocking frameworks available: <a href="http://nmock.org/">NMock</a>, <a href="http://www.easymock.org/">EasyMock</a>, <a href="http://code.google.com/p/moq/">Moq</a>, <a href="http://www.telerik.com/products/mocking.aspx">JustMock</a> (commercial), <a href="http://www.typemock.com/">TypeMock</a> (comercial), <a href="http://hibernatingrhinos.com/open-source/rhino-mocks">RhinoMocks</a>, <a href="http://nsubstitute.github.com/">NSubstitute</a>, <a href="http://code.google.com/p/fakeiteasy/">FakeItEasy</a> and <a href="http://research.microsoft.com/en-us/projects/moles/">Moles</a>.<br /><br />In our application we have decided for RhinoMocks and Moles. Moles are used in connection with Pex - test generation framework, which will be described later.<br />Most of the Mocking frameworks provide more or less the same functionalities thus the decision is quite complicated. RhinoMocks has the following characteristics: <br /><ul><li>Free and Open Source</li><li>Easy to use</li><li>Active community</li><li>Compatible with Silverlight (existing port to Silverlight)</li></ul>Possible disadvantage: three types of syntax, which might be confusing for beginners<br />Actual version 3.6, version 4 which should break backwards compatibility is <a href="http://ayende.com/blog/4169/planning-for-rhino-mocks-4-0">in development</a>, but if I have not missed something, there are so far no releases. <br /><br /><br /><b>Pex & Moles - Parametrized Unit Testing</b><br /><a href="http://research.microsoft.com/en-us/projects/pex/">Pex & Moles</a> are used in order to build Unit Tests for the back-end part. Pex is a tool which helps generate inputs for unit tests while Moles enables the isolation of tested code. In order for Pex to generate the inputs the the test cases have to be parametrized.<br /><br />Instead of writing concrete test cases, the test method is just a wrapper which takes the same arguments as the tested method, performs necessary set-up and then passes the arguments to the tested method. Pex analyses the execution tree of tested method and suggests the parameters which should be passed to the method and builds concrete test cases.<br /><br />The aim of Pex is to obtain maximal code coverage. In order to achieve that, it uses algebraic solver (<a href="http://research.microsoft.com/en-us/um/redmond/projects/z3/">Microsoft’s Z3</a>) to determine the values of variables used in the method which will lead to execution of each branch. Than it varies the parameters to obtain these values.<br /><br />Moles is a stubbing framework. It allows you to isolate the parts of the code which you want to test from other layers. There are basically two reasons why use Moles:<br />Moles works great with Pex. Because Pex explores the execution tree of your code, so it also tries to enter inside all the mocking frameworks which you might use. This can be problematic, since Pex will generate inputs which will cause exceptions inside the mocking frameworks. By contrast Moles generates simple stubs of classes containing delegates for each method, which are completely customizable and transparent.<br />Moles allows to stub static classes, including the ones of .NET framework which are usually problematic to mock(typically DateTime, File, etc)<br /><br />As it says on the official web: "Moles allows you to replace any .NET method by delegate". So before writing your unit test, you can ask Moles to generate the needed stubs for any assembly (yours or other) and than use these “moles” in your tests.<br /><br /><h3>Presentation Layer</h3>The presentation layer is quite large topic with several choices: ASP.NET,  ASP.MVC + JavaScript, pure HTML5 + JavaScript, some JS frameworks (jQuery, KnockOutJS, Silverlight - and all of these technologies can be combined.<br /><br /><b>Silverlight</b><br />Here is a list of characteristics which can be seen as advantages:<br /><ul><li>Intend ed to develop Rich Internet Applications.</li><li>Supports separation of the view and the logging using the MVVM pattern.</li><li>Possibility to use declarative language (XAML) to design user interface and imperative language tode ne the application logic.</li><li>Data visualization support u sing open source Silverlight Toolkit (charts, line series)</li><li>Re-usability of code on .NET compliant platform.</li><li>Possibility to access audio and video devices on client side.</li><li>Plug-in based technology. Requires the plug-in to be run inside the browser. The plug-in is not available for all possible combinations of platform and browser. This lowers the availability of the developed application and brings also higher requirements on hardware.</li><li>Standard web features are missing such as navigation.</li><li>Limited testability. Silverlight can not be tested with traditional functional testing frameworks such as Selenium. On the other hand, when the MVVM pattern is implied, the ViewModels can be tested as simple classes, using traditional Unit Testing technologies.</li></ul><br /><b>HTML + JavaScript</b><br /><ul><li>No plug-in needed, HTML 5 is supported on the majority of the current browsers.</li><li>Naturally comes with web standard features: navigation, bookmarking.</li><li>Developers has to handle the "all browsers compatibility" issue.</li><li>Compared to C\# JavaScript is dynamic language, not compiled before the execution. This may be seen as advantage and disadvantage.</li></ul><br />Knouckout.JS seems to me as a great possibility to use the MVVM pattern  with JavaScript, I will be checking it and writing about it later.<br /><br /><h3>Logging</h3>Logging is an essential part of each application. Following frameworks are available in .NET: <br /><ul><li><br /><a href="">Log4Net</a> - easy configurable framework.</li><li>Logging in MS Enterprise library</li><li><a href="http://nlog-project.org/">NLog</a> - version 2.0 released 7/2011 including logging framework for Windows Phone 7 and Silverlight - seems very nice, but I have never tried.</li><li>The Objects Guy Logging Framework - lightweight logging framework</li><li>.NET build-in tracing - alternative approach of using System.Diagnostics namespace which enables output of standard Trace and Debug Write method to XML file.</li></ul>Good recapitulation for logging is available at <a href="http://stackoverflow.com/questions/4775194/when-should-i-use-tracing-vs-logger-net-enterprise-library-log4net-or-ukadc-di">this stackoverflow thread.</a><br /><br /><h3>Security</h3>There is usually a need to handle the user authentication in enterprise applications. When using ASP.NET I have found out that there are the standard <a href="http://support.microsoft.com/kb/301240">Forms Authentication</a> usually satisfies my needs. To handle OpenID authentication <a href="http://www.dotnetopenauth.net/">DotNetOpenAuth</a> is an excellent choice.<br /><br /><b>Forms Authentication</b><br />Forms Authentication scheme works by issuing a token to user the first time that he authenticates. User can be authenticated against database or any other information source.<br /><br />This token in the form of cookie is added to the response which follows the authentication request. This way the cookie is added to the next request by the same client. Forms Authentication than takes care of revoking the cookie (after demanded time)  as well as of checking the cookie in each requests.<br /><br />Forms Authentication works automatically with browser based clients, when used from different clients, some additional work on the client has to be done in order to add the authentication cookie to each request.<br /><br /><b>DotNetOpenAuth</b><br /><br />I have previously used this library for two task: integrating OpenID authentication and <a href="http://honga.super6.cz/2011/08/using-dotnetopenauth-to-create-oauth.html">creating OAuth provider.</a><br /><br />Integration of OpenID works hand in hand with Forms Authentication. DotNetOpenAuth library provides a means to authenticate user against any Open ID provider. Once the user is authenticated the authentication cookie can be generated using Forms Authentication.<br /><br /><h3>Conclusion</h3>When new application is being developed, there are several decisions, that have to be taken regarding the framework and technologies which might be used. This article does not give direct answers to these question, but rather lists all the possible frameworks which should be taken into account.<br /><br />New frameworks are being delivered by Microsoft and by Open Source community and it is hard to see which technologies will hold on which will be forgotten. I hope this overview can help to make the right decision. Any suggestions are welcomed.<br /><a href="http://www.codeproject.com/script/Articles/BlogFeedList.aspx?amid=honga" rel="tag" style="display:none">CodeProject</a>