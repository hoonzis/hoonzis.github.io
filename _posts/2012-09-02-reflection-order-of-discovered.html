---
layout: post
title: Reflection & Order of discovered properties
date: '2012-09-02T12:24:00.002-07:00'
author: Jan Fajfr
tags:
- ".NET"
- C#
modified_time: '2014-06-26T14:20:55.050-07:00'
blogger_id: tag:blogger.com,1999:blog-1710034134179566048.post-5448790318473932249
blogger_orig_url: http://hoonzis.blogspot.com/2012/09/reflection-order-of-discovered.html
---

In .NET environement Reflection provides several methods to obtain information about any type from the type system. One of these methods is <b>GetProperties</b> method which retrieves a list of all the properties of a given type. This method returns an array of <b>PropertyInfo</b> objects.  <pre class="prettyprint"><br />PropertyInfo[] propListInfo = type.GetProperties();<br /></pre> In most cases you don't care, but the order of the properties does not have to be the same if you run this method several times. This is well described in <a href="http://msdn.microsoft.com/en-us/library/kyaxdd3x.aspx">the documentation of this method.</a> Microsoft also states, that your code should not be depending on the order of the properties obtained. <br/><br/>I had a very nice example of a bug resulting from the misuse of this method. A ObjectComparer<T> class, which is dedicated to comparison of two objects of same type by recursively comparing it's properties, which I have inherited as legacy code on my current Silverlight project. <br/><br/>I have noticed, that the results of the comparison are not the same every time I run the comparison. Concretely the first time the comparison was run on two same objects it always told me, that the objects are not equal. Take a look at the problematic code, which I have simplified a bit for this post: <pre class="prettyprint"><br />private static bool CompareObjects(object initialObj, object currentObj, IList&lt;String&gt; filter)<br />{<br /> string returnMessage = string.Empty;<br /><br /> Type type = initialObj.GetType();<br /> Type type2 = currentObj.GetType();<br /><br /> PropertyInfo[] propListInfo = type.GetProperties(BindingFlags.GetProperty | BindingFlags.Public | BindingFlags.Instance).Where(x => !filter.Contains(x.Name)).ToArray();<br /> PropertyInfo[] propListInfo1 = type2.GetProperties(BindingFlags.GetProperty | BindingFlags.Public | BindingFlags.Instance).Where(x => !filter.Contains(x.Name)).ToArray();<br /><br /> //if class type is native i.e. string, int, boolean, etc.<br /> if (type.IsSealed == true && type.IsGenericType == false)<br /> {<br />  if (!initialObj.Equals(currentObj))<br />  {<br />   return false;<br />  }<br /> }<br /> else //class type is object<br /> {<br />  //loop through each property of object<br />  for (int count = 0; count &lt; propListInfo.Length; count++){<br />   var result = CompareValues(propListInfo[count].GetValue(initialObj),propListInfo2[count].GetValue(currentObj));<br />   if(result == false) {<br />    return result;<br />   }<br />  }<br /> }<br /> return true;<br />}<br /></pre>So in order to correct this code, you will have to <b>order both arrays by MetadataToken</b>, which is a unique identifier of each property. <pre class="prettyprint"><br />propListInfo = propListInfo.OrderBy(x=>x.MetadataToken).ToArray();<br />propListInfo1 = propListInfo1.OrderBy(x=>x.MetadataToken).ToArray();<br /></pre>There is some more information about how reflection works <a href="http://blogs.msdn.com/b/haibo_luo/archive/2006/07/09/661091.aspx ">in this blog post.</a>The issue is that the Reflection engine holds a "cache" for each type, in which it stocks the already "discovered" properties. The problem is that, this cache is cleared during garbage collection. When we ask for the properties, than they are served from the cache in the order in which they have been discovered. <br/><br/>However in my case, this information does not help. The issue occures only the first time that I ask the ObjectComparator to compare the objects and there is no reason that there should be any garbage collection between the first and second run...well no idea here. Sorting by MetadataToken has fixed the issue for me. <a href="http://www.codeproject.com/script/Articles/BlogFeedList.aspx?amid=honga" rel="tag" style="display: none;">CodeProject</a>