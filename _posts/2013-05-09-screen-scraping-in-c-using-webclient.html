---
layout: post
title: Screen scraping in C# using WebClient
date: '2013-05-09T01:08:00.000-07:00'
author: Jan Fajfr
tags:
- C#
modified_time: '2014-06-26T10:37:24.329-07:00'
blogger_id: tag:blogger.com,1999:blog-1710034134179566048.post-6719751879680739053
blogger_orig_url: http://hoonzis.blogspot.com/2013/05/screen-scraping-in-c-using-webclient.html
---

<p>This post is intended to give you some useful tips to perform screen scraping in C#. Well first let's put it clear. In the ideal world we should not be forced to do screen scraping. Every solid web site, application or service should propose a decent API to provide the data to other applications. If the application holds resources of it's users, than it should propose OAuth protected API and thus allow the users to use their data through another application. But we are not yet in this situation.</p> <h2>Observing the communication</h2><p>In order to know what kind of HTTP request you have to issue, you have to observe what the browser is doing when you browse the web page. There is not a better tool for the job than <a href="http://fiddler2.com/">Fiddler</a>. One of the features provided which you might find really useful is that it can <b>automatically decrypt HTTPS traffic.</b></p> <h2>Getting the data</h2><p>Once you determine which web requests you should replay you need the infrastructure necessary to execute the requests. .NET provides the <b>WebClient</b> class. Note that WebClient is a facade for using creating and handling HttpWebRequest and HttpWebResponse objects. Feel free to use these classes directly if you want, but by default the compiler will not like their usage since they are marked as obsolote.</p><h2>Parsing the data</h2><p>If you are just need to screen scrape a simple site which is invoked by HTTP GET request, than you do not need any special information. You can just fire <b>WebClient</b>, obtain the string and than parse the result. When parsing the result, you have to keep in mind, that HTML is not a regular language. Therefor you cannot always use Regular Expressions to parse it. However you can usually get around with it. A common task is to match some information in some concrete tag, here are two examples:</p> <p>Matching any text inside a div with some special styles:</p><pre class="prettyprint"><br />&lt;div style="font:bold 11px verdana;color:#cf152c"&gt;Important information&lt;/div&gt;<br /></pre> <pre class="prettyprint"><br />var addressTerm = new Regex("&lt;div style=\"font:bold 11px verdana;color:#cf152c;\"&gt;(?&lt;match&gt;[^&lt;]*?)&lt;/div&gt;");<br /></pre> <p>Matching two decimal values inside a div separated by BR tag:</p><pre class="prettyprint"><br />&lt;div style=\"margin-left:5px;float:left;font:bold 11px verdana\"&gt;10&lt;br /&gt;12&lt;br /&gt;&lt;/div&gt;<br /></pre><pre class="prettyprint"><br />var dataTerm = new Regex("&lt;div style=\"margin-left:5px;float:left;font:bold 11px verdana;color:green\"&gt;(?&lt;free&gt;\\d*)&lt;br /&gt;(?&lt;places&gt;\\d*)&lt;br /&gt;&lt;/div&gt;");<br /></pre> <h2>Posting values</h2><p>When submiting a form to a web application, the browser usually performs a http POST request and encodes the values to the posting URL. In order to create such a request, you have to set the content type of the request to <b>application/x-www-form-urlencoded</b>. Then you can use the <b>UploadData</b> of the WebClient.</p><pre class="prettyprint"><br />using(var client = new WebClient()){<br /> var contentType = "application/x-www-form-urlencoded";<br /> client.Headers.Add("Content-Type", contentType);<br /> <br /> var values = new NameAndValueCollection();<br /> values.Add("name", name);<br /> values.Add("pass", pass);<br /> var response = client.UploadValues(url, "POST", values);<br />}<br /></pre><h2>Handling the authentification</h2><p>In  some cases you have to pass the authentication before you get to the information that you need. Most of the web sites use cookie based authentication. Once the user is authenticated the server generates an authentication cookie which than is automatically added to any susccesive request by the web browser. By default <b>WebClient</b> does not accept store cookies. The infrastructure to handle cookies is implemented on the level of HttpWebRequest. I have found a very useful example of "cookie aware" WebClient which keeps all the cookies that it has recieved so far and adds them to any newer request on the following StackOverflow link:</p><a href="http://stackoverflow.com/questions/1777221/using-cookiecontainer-with-webclient-class">http://stackoverflow.com/questions/1777221/using-cookiecontainer-with-webclient-class</a><pre class="prettyprint"><br />public class WebClientEx : WebClient<br />{<br />    public WebClientEx(CookieContainer container)<br />    {<br />        this.container = container;<br />    }<br /><br />    private readonly CookieContainer container = new CookieContainer();<br /><br />    protected override WebRequest GetWebRequest(Uri address)<br />    {<br />        WebRequest r = base.GetWebRequest(address);<br />        var request = r as HttpWebRequest;<br />        if (request != null)<br />        {<br />            request.CookieContainer = container;<br />        }<br />        return r;<br />    }<br /><br />    protected override WebResponse GetWebResponse(WebRequest request, IAsyncResult result)<br />    {<br />        WebResponse response = base.GetWebResponse(request, result);<br />        ReadCookies(response);<br />        return response;<br />    }<br /><br />    protected override WebResponse GetWebResponse(WebRequest request)<br />    {<br />        WebResponse response = base.GetWebResponse(request);<br />        ReadCookies(response);<br />        return response;<br />    }<br /><br />    private void ReadCookies(WebResponse r)<br />    {<br />        var response = r as HttpWebResponse;<br />        if (response != null)<br />        {<br />            CookieCollection cookies = response.Cookies;<br />            container.Add(cookies);<br />        }<br />    }<br />}<br /></pre><h3>Diggest authentication</h3><p>Some web site may employ "digest" authentication, which based on hashing, adds a little more security againts "man-in-the-middle attacks. In that case you will see, that a login request is not just composed of a simple POST request with the "login" and "password" values. Instead a combination of random value (which the server knows) and the password is composed, hashed together and sent to the server.</p><pre class="prettyprint"><br />digestPassword = hash(hash(login+password)+nonce);<br /></pre><p>Nonce - in the previous definition is the "Number Used Only Once", which is generated by the server and which the server keeps in a pool in order to keep track of already used values. Here are two simple methods to create a digestPassword:</p><pre class="prettyprint"><br />public static String DigestResponse(String idClient, String password, String nonce)<br />{<br /> var cp = idClient + password;<br /> var hashedCP = CalculateSHA1(cp, Encoding.UTF8);<br /> var cnp = hashedCP + nonce;<br /> return CalculateSHA1(cnp, Encoding.UTF8);<br />}<br /><br />public static string CalculateSHA1(string text, Encoding enc)<br />{<br /> byte[] buffer = enc.GetBytes(text);<br /> var cryptoTransformSHA1 = new SHA1CryptoServiceProvider();<br /> return BitConverter.ToString(cryptoTransformSHA1.ComputeHash(buffer)).Replace("-", "").ToLower();<br />}<br /></pre><p>Ofcourse when using the digest authentication, the server has to provide the value of the "Nonce" to the client. The value is usually a part of the login page and the authentication and the hashing is one in JavaScript</p><h2>State-full JSF applications</h2><p>Most of the web applications that we see today are composed of stateless services. There are some really good reasons for that, however it is still posible that you might have to analyze a stateful application. In this situation the order of the http web requests matters. JSF is one of such web technologies which favor stateful applications. In my case I needed to obtain a CSV file which was generated using the data previously shown to the user in a HTML table. The way this was done, was that the ID of the table element was passed to the CSV generation request. So these two requests were interconnected. More than that, the ID value was generated by JSF and I think that it was dependent on the number of previously generated HTML elements. Typically the generated ID values are prefixed by "j_id" and if I wanted to hardcode this value, I had to compose always exactly the same set of HTTP requests.</p><pre class="prettyprint"><br />values.Add("source", "j_id630");<br /></pre> <h2>Make them think you are a serious browser</h2><p>Some web page check for the browser accessing the page, you can easily make them think you are Mozilla Firefox:</p><pre class="prettyprint"><br />var mozilaAgent = "Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)";<br />client.Headers.Add("User-Agent", mozilaAgent);<br /></pre><h2>Summary</h2><p>If there is any other way to obtain the data, than it is probably better way. If you cannnot avoid it, I hope this gave you couple hints.</p>