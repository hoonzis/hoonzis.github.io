---
layout: post
title: Using DotNetOpenAuth to create OAuth Provider
date: '2011-08-17T03:43:00.000-07:00'
author: Jan Fajfr
tags:
- OAuth
- WCF
modified_time: '2014-06-26T14:49:34.166-07:00'
thumbnail: http://3.bp.blogspot.com/-RavCX64q2tQ/TkubMhKbDnI/AAAAAAAAAMk/aUfz87m9-ks/s72-c/OAuth_workflow.png
blogger_id: tag:blogger.com,1999:blog-1710034134179566048.post-8586859066855713132
blogger_orig_url: http://hoonzis.blogspot.com/2011/08/using-dotnetopenauth-to-create-oauth.html
---

<a href="https://github.com/hoonzis/OAuthPoc">Download the source code from GitHub.</a><br /><a href="http://www.dotnetopenauth.net/">DotNetOpenAuth</a> is an open source library created and managed by Andrew Arnott which gives you the <br />possibility to use OAuth protocol, OpenID and ICard. It si powerful - and comes with a nice Samples package. Recently I needed to implement OAuth provider, in other words I wanted to allow third party application to obtain data from my application after the user authorizes them to do so.<br /><br />Before I have implemented that for my application, I have created a simple Proof of Concept (POC), which I will share with you. Basically it is just a simplified version of the OAuthProvider project in the Samples package. That is a greate example, however one fact, that might be little confusing is that it uses Linq to SQL to store the authentication Tokens and if you do not want to enter into that you might get lost. My targeted application uses NHibernate for ORM, but I decided to make the POC only store data in the memmory to keep it as simple as I could.<br /><br />At the end I will just lay out how I incorporated DotNetOpenAuth to my application, where I already had Data Access layer established using NHibernate.<br /><br />To understand the rest of this post, you need to understand the basics of OAuth protocol.<br /><br />Here is the standard way of communication between Consumer and Provider using OAuth protocol.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-RavCX64q2tQ/TkubMhKbDnI/AAAAAAAAAMk/aUfz87m9-ks/s1600/OAuth_workflow.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="172" src="http://3.bp.blogspot.com/-RavCX64q2tQ/TkubMhKbDnI/AAAAAAAAAMk/aUfz87m9-ks/s320/OAuth_workflow.png" width="320" /></a></div><br /><br /><br />DotNetOpenAuth provides classes and structures which enable you to easily create OAuth Consumer or Provider and manipulate Tokens. However each both Consumer and Provider have to decide on how to handle and store the Tokens.<br /><br />The basic scenario is this:<br />Provider exposes WCF service which is secured using OAuth protocol. Consumer can access this services only when he obtains authorization of the actual user and owner of the resources.<br />Here is a digram which shows the structure of OAuth Provider when implemented using DotNetOpenAuth.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-oS8jJbVEYVA/Tkuad-us3hI/AAAAAAAAAMc/9Spm67ziNUY/s1600/oauth_provider_consumer.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="134" src="http://1.bp.blogspot.com/-oS8jJbVEYVA/Tkuad-us3hI/AAAAAAAAAMc/9Spm67ziNUY/s320/oauth_provider_consumer.png" width="320" /></a></div><br />There are two entities which perform the communication. First it is simple Http Handler which takes care of the OAuth "handshake". The second is the actual WCF service which uses custom Authorization Manager to perform the authentication. Both of these make use of the Service Provider (comming from DotNetOpenAuth). Service Provider than uses implementations of IServiceProviderTokenManager and INonceStore also defined in DotNetOpenAuth, which take care of the persistance of Nonces and Tokens. It is up to the programmer to decide how to implement these interfaces.<br /><br />OAuth provider needs to store three types of objects: Consumers, Tokens and Nonces. To keep it simple, I decided to store all of them in memory in lists inside applications Global file.<br /><br /><pre class="prettyprint"><br />public class Global : System.Web.HttpApplication<br />{<br />  public static List&lt;OAuthConsumer&gt; Consumers { get; set; }<br />  public static List&lt;OAuthToken&gt; AuthTokens { get; set; }<br />  public static List&lt;Nonce&gt; Nonces { get; set; }  <br />}<br /></pre><br />Now these list are then used by ServiceProvider, actually by IServiceProviderTokenManager and INonceStore, which later in turn are used by ServiceProvider. Lets first take a look at the IServiceProviderTokenManager interface (<a href="http://docs.dotnetopenauth.net/master/html/AllMembers_T_DotNetOpenAuth_OAuth_ChannelElements_IServiceProviderTokenManager.htm">definition is here</a>). For example the GetRequestToken method would be implemented like this:<br /><pre class="prettyprint"><br />public IServiceProviderRequestToken GetRequestToken(string token)<br />{<br /><br />    var foundToken = Global.AuthTokens.FirstOrDefault(t =&gt; t.Token == token &amp;&amp; t.State != TokenAuthorizationState.AccessToken);<br />    <br />    if(foundToken==null)<br />    {<br />        throw new KeyNotFoundException("Unrecognized token");<br />    }<br />    return foundToken;<br />}<br /></pre><br />So it is quite easy. The method actually returns IServiceProviderRequestToken, methods which work with Nonces or Consumer also return interfaces defined by DotNetOpenAuth, so in other words all of your business entities which encapsulate Consumer, Tokens or Nonces have to implement these interfaces defined by DotNetOpenAuth.<br /><br />There are two types of tokens: Request Token (IServiceProviderRequestToken) and Access Token (IServiceProviderAccessToken). During the OAuth handshake, the request token is interchanged for the access token. So you can actually create one class which implements both of these interfaces. In that case <b>implement these interfaces explicitely</b> because there are Properties which have to be implemented with same name. There are two properties which are returning String called Token (one comming from Access Token and other from Request Token interface), here is the way in which they are implemented:<br /><pre class="prettyprint"><br />private String _token;<br />String IServiceProviderRequestToken.Token<br />{<br />    get { return _token; }<br />}<br /><br />String IServiceProviderAccessToken.Token <br />{<br />    get { return _token; }<br />}<br /><br />public String Token { <br />    set { <br />        _token = value;  <br />    }<br />}<br /></pre><p>When the Token changes from Request to Access token, the actual String value stays the same. So I have backed up both of these properties by the same private field and added a property which will allows me to set this field.</p><p>Basically thats it. There is much more code around but actually I just took most of the code comming from the official set of examples.</p><h2>Using NHibernate to persists Tokens, Consumer and Nonces</h2>In the project where I needed to implement OAuth provider, I was using NHibernate as my ORM with NFluent(nice framework which allows to write configuration of NHibernate in C#). What I like about this combination is the fact, that there is no XML file and generated properties (such as with Linq2SQL).<br />I always try to keep my database entities as clear as possible, that is why I did not want my entities to implement the interfaces forced by DotNetOpenAuth. Instead of that I wrapped my entities by classes which are using these interfaces and use the database persisted entities as backup. So just to explain what I mean, here is the persistant class:<br /><pre class="prettyprint"><br />public class AuthToken<br />{<br />    public virtual int Id { get; set; }<br />    public virtual AuthConsumer Consumer { get; set; }<br />    public virtual AuthTokenState State { get; set; }<br />    public virtual DateTime IssueDate { get; set; }<br />    public virtual UserIdentity User { get; set; }<br />    public virtual String TokenSecret { get; set; }<br />    public virtual String Scope { get; set; }<br />    public virtual String Token { get; set; }<br />    public virtual String Version { get; set; }<br />    public virtual String VerificationCode { get; set; }<br />    public virtual DateTime? ExpirationDate { get; set; }<br />    public virtual String[] Roles { get; set; }<br />    public virtual String Callback { get; set; }<br />}<br /></pre>And here the DotNetOpenAuth compatible wrapper:<br /><pre class="prettyprint"><br />public class OAuthToken : IServiceProviderRequestToken, IServiceProviderAccessToken<br />{<br />    public OAuthToken(AuthToken token)<br />    {<br />        if (token == null)<br />        {<br />            throw new ArgumentNullException("Token passed to constructor of OAuthToken cannot be null");<br />        }<br />        Token = token;<br />    }<br /><br />    public OAuthToken()<br />    {<br />        Token = new AuthToken();<br />    }<br /><br />    public AuthToken Token {get;set;}<br /><br />    #region IServiceProviderRequestToken<br /><br />    Uri IServiceProviderRequestToken.Callback<br />    {<br />        get<br />        {<br />            return new Uri(Token.Callback);<br />        }<br />        set<br />        {<br />            if (value != null)<br />            {<br />                Token.Callback = value.AbsoluteUri;<br />            }<br />        }<br />    }<br /><br />    string IServiceProviderRequestToken.ConsumerKey<br />    {<br />        get { return Token.Consumer.ConsumerKey; }<br />    }<br /><br />    Version IServiceProviderRequestToken.ConsumerVersion<br />    {<br />        get<br />        {<br />            if (Token == null || Token.Version == null)<br />            {<br />                throw new ArgumentNullException("The Token or the Version are null");<br />            }<br />            return new Version(Token.Version);<br />        }<br />        set<br />        {<br />            Token.Version = value.ToString();<br />        }<br />    }<br /><br />    DateTime IServiceProviderRequestToken.CreatedOn<br />    {<br />        <br />        get {<br />            return Token.IssueDate.ToLocalTime(); }<br />    }<br /><br />    string IServiceProviderRequestToken.Token<br />    {<br />        get { return Token.Token; }<br />    }<br /><br />    string IServiceProviderRequestToken.VerificationCode<br />    {<br />        get<br />        {<br />            return Token.VerificationCode;<br />        }<br />        set<br />        {<br />            Token.VerificationCode = value;<br />        }<br />    }<br /><br />    #endregion<br /><br />    #region IServiceProviderAccessToken<br /><br />    DateTime? IServiceProviderAccessToken.ExpirationDate<br />    {<br />        get { return Token.ExpirationDate; }<br />    }<br /><br />    string[] IServiceProviderAccessToken.Roles<br />    {<br />        get { return Token.Roles; }<br />    }<br /><br />    string IServiceProviderAccessToken.Token<br />    {<br />        get { return Token.Token; }<br />    }<br /><br />    string IServiceProviderAccessToken.Username<br />    {<br />        get {<br />            if (Token.User == null)<br />            {<br />                throw new ArgumentNullException("Token does not have assigned user");<br />            }<br />            return Token.User.Identification; <br />        }<br />    }<br />    #endregion<br />}<br /></pre>In that case the Token Manager has to take care of the conversation with database as well as with wrapping the recieved entities.<br /><pre class="prettyprint"><br />public class DatabaseTokenManager : IServiceProviderTokenManager<br />{<br />  private IOAuthServices _oAuthServices;<br />  <br />  public IOAuthServices OAuthServices<br />  {<br />      get {<br />          if (_oAuthServices == null)<br />          {<br />              _oAuthServices = get your service class which talks to the database....<br />          }<br />          return _oAuthServices;<br />      }<br />  }<br />  <br />  public IServiceProviderRequestToken GetRequestToken(string token)<br />  {<br />      var authToken = OAuthServices.GetRequestToken(token);<br />      if (authToken == null)<br />      {<br />          throw new SecurityException("No token found: " + token);<br />      }<br />      return new OAuthToken(authToken);<br />  }<br />}<br /></pre>The rest stays the same and it works fine.<br />It took me some time to understand how DotNetOpenAuth on the provider site works. I hope this post can help someone to jump in fast.<br /><br /><a href="https://github.com/hoonzis/OAuthPoc">Get the code from GitHub</a>